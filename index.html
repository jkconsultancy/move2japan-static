<!DOCTYPE html>
<html class="light" lang="en">
<head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  
  <!-- SEO Meta Tags -->
  <title>Moving to Japan Checklist - Complete Guide for US Citizens | Move2Japan</title>
  <meta name="description" content="A comprehensive, interactive checklist for moving to Japan from the US. Track your progress through visa applications, housing, banking, and all essential tasks for relocating to Japan.">
  <meta name="keywords" content="moving to Japan, Japan relocation checklist, US to Japan move, Japan visa guide, relocate to Japan, Japan immigration checklist, Japan moving guide, expat Japan">
  <meta name="author" content="Move2Japan">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://move2japan.com/">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://move2japan.com/">
  <meta property="og:title" content="Moving to Japan Checklist - Complete Guide for US Citizens">
  <meta property="og:description" content="A comprehensive, interactive checklist for moving to Japan from the US. Track your progress through visa applications, housing, banking, and all essential tasks.">
  <meta property="og:image" content="https://images.unsplash.com/photo-1478436127897-769e1b3f0f36?q=80&w=1200&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:alt" content="Beautiful landscape view of Japan with mountains and traditional architecture">
  <meta property="og:site_name" content="Move2Japan">
  <meta property="og:locale" content="en_US">
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://move2japan.com/">
  <meta name="twitter:title" content="Moving to Japan Checklist - Complete Guide for US Citizens">
  <meta name="twitter:description" content="A comprehensive, interactive checklist for moving to Japan from the US. Track your progress through visa applications, housing, banking, and all essential tasks.">
  <meta name="twitter:image" content="https://images.unsplash.com/photo-1478436127897-769e1b3f0f36?q=80&w=1200&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D">
  <meta name="twitter:image:alt" content="Beautiful landscape view of Japan with mountains and traditional architecture">
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  
  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Moving to Japan Checklist",
    "description": "A comprehensive, interactive checklist for moving to Japan from the US. Track your progress through visa applications, housing, banking, and all essential tasks for relocating to Japan.",
    "url": "https://move2japan.com/",
    "applicationCategory": "UtilityApplication",
    "operatingSystem": "Web",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "featureList": [
      "Interactive checklist with progress tracking",
      "Visa and immigration guidance",
      "Housing and banking resources",
      "Comprehensive relocation tasks",
      "Resource links for each task"
    ]
  }
  </script>
  
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  
  <!-- Application Modules -->
  <script src="/js/StateManager.js"></script>
  <script src="/js/ChecklistDataManager.js"></script>
  <script src="/js/DragDropManager.js"></script>
  <script src="/js/TaskRenderer.js"></script>
  <script src="/js/SubcategoryRenderer.js"></script>
  <script src="/js/PhaseRenderer.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;600;700&display=swap" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet"/>
  <script src="https://t.contentsquare.net/uxa/5947da0fdab10.js"></script>
  <!-- Cloudflare Web Analytics -->
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "3f2ed07ac03a48759de724f05c9b8d9a"}'></script>
  <script>
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            primary: "#0EA5E9", // sky-500
            "background-light": "#F8FAFC", // slate-50
            "background-dark": "#020617", // slate-950
          },
          fontFamily: {
            display: ["Sora", "sans-serif"],
          },
          borderRadius: {
            DEFAULT: "0.5rem", // 8px
          },
        },
      },
    };
  </script>
  <style>
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }
    .strikethrough {
      text-decoration: line-through;
      color: #94a3b8;
    }
    .dark .strikethrough {
      color: #64748b;
    }
    /* Indeterminate checkbox styling */
    input[type="checkbox"]:indeterminate {
      background-color: #0EA5E9;
      border-color: #0EA5E9;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='none' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3E%3C/svg%3E");
    }
    /* Line clamp utility */
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    /* Drag and drop styles */
    .dragging {
      opacity: 0.5;
    }
    .drag-over {
      border-top: 2px solid #0EA5E9;
      background-color: rgba(14, 165, 233, 0.1);
    }
    .dark .drag-over {
      background-color: rgba(14, 165, 233, 0.2);
    }
    /* Links container max-height for desktop */
    @media (min-width: 1024px) {
      #links-container {
        max-height: calc(100vh - 8rem);
      }
    }
    /* Swipe to delete container */
    .swipe-container {
      position: relative;
      overflow: hidden;
      width: 100%;
    }
    .swipe-content {
      position: relative;
      width: 100%;
      transition: transform 0.3s ease-out;
      background-color: inherit;
    }
    .swipe-content.swiped {
      transform: translateX(-80px);
    }
    .swipe-content-resource.swiped {
      transform: translateX(-160px);
    }
    .swipe-edit {
      position: absolute;
      right: 80px;
      top: 0;
      bottom: 0;
      width: 80px;
      background-color: #0EA5E9;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
    }
    .swipe-content-resource.swiped ~ .swipe-edit {
      display: flex;
    }
    .swipe-edit:hover {
      background-color: #0284c7;
    }
    .swipe-edit .material-symbols-outlined {
      color: white;
      font-size: 24px;
    }
    .swipe-delete {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 80px;
      background-color: #ef4444;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
    }
    .swipe-content.swiped ~ .swipe-delete,
    .swipe-content-resource.swiped ~ .swipe-delete {
      display: flex;
    }
    .swipe-delete:hover {
      background-color: #dc2626;
    }
    .swipe-delete .material-symbols-outlined {
      color: white;
      font-size: 24px;
    }
    /* Swipe refresh button (for Overall Progress) */
    .swipe-refresh {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 80px;
      background-color: #0EA5E9;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
    }
    .swipe-refresh:hover {
      background-color: #0284c7;
    }
    .swipe-refresh .material-symbols-outlined {
      color: white;
      font-size: 24px;
    }
    .swipe-content.swiped ~ .swipe-refresh {
      display: flex;
    }
    /* Dialog/Modal styles */
    .dialog-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }
    .dialog-content {
      background-color: white;
      border-radius: 0.5rem;
      padding: 1.5rem;
      max-width: 500px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    }
    .dark .dialog-content {
      background-color: #0f172a;
    }
    .dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    .dialog-title {
      font-size: 1.25rem;
      font-weight: 700;
      color: #0f172a;
    }
    .dark .dialog-title {
      color: white;
    }
    .dialog-close {
      background: none;
      border: none;
      cursor: pointer;
      color: #64748b;
      padding: 0.25rem;
    }
    .dialog-close:hover {
      color: #0f172a;
    }
    .dark .dialog-close:hover {
      color: white;
    }
    .dialog-form-group {
      margin-bottom: 1rem;
    }
    .dialog-label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      color: #0f172a;
      margin-bottom: 0.5rem;
    }
    .dark .dialog-label {
      color: #e2e8f0;
    }
    .dialog-input {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #cbd5e1;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      background-color: white;
      color: #0f172a;
    }
    .dark .dialog-input {
      background-color: #1e293b;
      border-color: #475569;
      color: white;
    }
    .dialog-textarea {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #cbd5e1;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      min-height: 80px;
      resize: vertical;
      background-color: white;
      color: #0f172a;
    }
    .dark .dialog-textarea {
      background-color: #1e293b;
      border-color: #475569;
      color: white;
    }
    .dialog-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }
    .btn-primary {
      background-color: #0EA5E9;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }
    .btn-primary:hover {
      background-color: #0284c7;
    }
    .btn-secondary {
      background-color: #e2e8f0;
      color: #0f172a;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }
    .dark .btn-secondary {
      background-color: #475569;
      color: white;
    }
    .btn-secondary:hover {
      background-color: #cbd5e1;
    }
    .dark .btn-secondary:hover {
      background-color: #64748b;
    }
    /* Add button styles */
    .add-button {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      margin-top: 0.5rem;
      background-color: #f1f5f9;
      border: 2px dashed #cbd5e1;
      border-radius: 0.5rem;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }
    .dark .add-button {
      background-color: #1e293b;
      border-color: #475569;
      color: #94a3b8;
    }
    .add-button:hover {
      background-color: #e2e8f0;
      border-color: #0EA5E9;
      color: #0EA5E9;
    }
    .dark .add-button:hover {
      background-color: #334155;
      border-color: #0EA5E9;
      color: #0EA5E9;
    }
    /* Editable title styles */
    .editable-title {
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      transition: background-color 0.2s;
    }
    .editable-title:hover {
      background-color: #f1f5f9;
    }
    .dark .editable-title:hover {
      background-color: #1e293b;
    }
    .editable-title[contenteditable="true"] {
      outline: 2px solid #0EA5E9;
      outline-offset: 2px;
      background-color: white;
    }
    .dark .editable-title[contenteditable="true"] {
      background-color: #1e293b;
    }
    /* Resource card edit icon */
    .resource-edit-icon {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      width: 32px;
      height: 32px;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 0.375rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 20;
      transition: background-color 0.2s;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .dark .resource-edit-icon {
      background-color: rgba(30, 41, 59, 0.9);
    }
    .resource-edit-icon:hover {
      background-color: rgba(255, 255, 255, 1);
    }
    .dark .resource-edit-icon:hover {
      background-color: rgba(30, 41, 59, 1);
    }
    .resource-edit-icon .material-symbols-outlined {
      color: #475569;
      font-size: 18px;
    }
    .dark .resource-edit-icon .material-symbols-outlined {
      color: #cbd5e1;
    }
    /* Email login modal styles */
    .email-modal-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      backdrop-filter: blur(4px);
    }
    .email-modal-content {
      background-color: white;
      border-radius: 0.75rem;
      padding: 2rem;
      max-width: 450px;
      width: 100%;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      animation: modalSlideIn 0.3s ease-out;
    }
    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    .dark .email-modal-content {
      background-color: #0f172a;
    }
    .email-modal-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #0f172a;
      margin-bottom: 0.5rem;
    }
    .dark .email-modal-title {
      color: white;
    }
    .auth-tab {
      flex: 1;
      padding: 12px;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      font-weight: 600;
      color: #64748b;
      transition: all 0.2s;
    }
    .auth-tab.active {
      color: #0ea5e9;
      border-bottom-color: #0ea5e9;
    }
    .auth-tab:hover {
      color: #0ea5e9;
    }
    .auth-form {
      display: block;
    }
    .email-modal-subtitle {
      font-size: 0.875rem;
      color: #64748b;
      margin-bottom: 1.5rem;
    }
    .dark .email-modal-subtitle {
      color: #94a3b8;
    }
    #email-form {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    .email-input {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #cbd5e1;
      border-radius: 0.5rem;
      font-size: 1rem;
      background-color: white;
      color: #0f172a;
      transition: border-color 0.2s;
    }
    .email-input:focus {
      outline: none;
      border-color: #0EA5E9;
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
    }
    .dark .email-input {
      background-color: #1e293b;
      border-color: #475569;
      color: white;
    }
    .dark .email-input:focus {
      border-color: #0EA5E9;
    }
    .email-submit-btn {
      width: 100%;
      padding: 0.75rem;
      background-color: #0EA5E9;
      color: white;
      border: none;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-top: 1rem;
    }
    .email-submit-btn:hover {
      background-color: #0284c7;
    }
    .email-submit-btn:disabled {
      background-color: #94a3b8;
      cursor: not-allowed;
    }
    .email-error {
      color: #ef4444;
      font-size: 0.875rem;
      margin-top: 0.5rem;
      display: none;
    }
    .email-success {
      color: #10b981;
      font-size: 0.875rem;
      margin-top: 0.5rem;
      display: none;
    }
  </style>
  <!-- MailerLite Styles -->
  <style type="text/css">@import url("https://assets.mlcdn.com/fonts.css?version=1762785");</style>
  <style type="text/css">
    /* LOADER */
    .ml-form-embedSubmitLoad {
      display: inline-block;
      width: 20px;
      height: 20px;
    }
    .g-recaptcha {
      transform: scale(1);
      -webkit-transform: scale(1);
      transform-origin: 0 0;
      -webkit-transform-origin: 0 0;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      border: 0;
    }
    .ml-form-embedSubmitLoad:after {
      content: " ";
      display: block;
      width: 11px;
      height: 11px;
      margin: 1px;
      border-radius: 50%;
      border: 4px solid #fff;
      border-color: #ffffff #ffffff #ffffff transparent;
      animation: ml-form-embedSubmitLoad 1.2s linear infinite;
    }
    @keyframes ml-form-embedSubmitLoad {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #mlb2-33402369.ml-form-embedContainer {
      box-sizing: border-box;
      display: table;
      margin: 0 auto;
      position: static;
      width: 100% !important;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper {
      background-color: transparent;
      border-width: 0px;
      border-color: transparent;
      border-radius: 4px;
      border-style: solid;
      box-sizing: border-box;
      display: inline-block !important;
      margin: 0;
      padding: 0;
      position: relative;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper.embedForm { 
      max-width: 100%; 
      width: 100%; 
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-align-center { 
      text-align: center; 
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody {
      padding: 0;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent {
      text-align: left;
      margin: 0 0 20px 0;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent h4 {
      color: #0f172a;
      font-family: 'Open Sans', Arial, Helvetica, sans-serif;
      font-size: 1.5rem;
      font-weight: 700;
      margin: 0 0 10px 0;
      text-align: left;
      word-break: break-word;
    }
    .dark #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent h4 {
      color: white;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p {
      color: #64748b;
      font-family: 'Open Sans', Arial, Helvetica, sans-serif;
      font-size: 0.875rem;
      font-weight: 400;
      line-height: 20px;
      margin: 0 0 10px 0;
      text-align: left;
    }
    .dark #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedContent p {
      color: #94a3b8;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody form {
      margin: 0;
      width: 100%;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-formContent {
      margin: 0 0 20px 0;
      width: 100%;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-formContent.horozintalForm {
      margin: 0;
      padding: 0 0 20px 0;
      width: 100%;
      height: auto;
      float: left;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow {
      height: auto;
      width: 100%;
      float: left;
      display: flex;
      gap: 10px;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .ml-input-horizontal {
      flex: 1;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .ml-button-horizontal {
      flex: 0 0 auto;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .horizontal-fields {
      width: 100%;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow {
      margin: 0 0 10px 0;
      width: 100%;
    }
    @media only screen and (max-width: 400px) {
      #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow {
        flex-direction: column;
      }
      #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .ml-input-horizontal {
        width: 100%;
      }
      #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow .ml-button-horizontal {
        width: 100%;
      }
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input {
      background-color: #ffffff !important;
      color: #0f172a !important;
      border-color: #cbd5e1;
      border-radius: 0.5rem !important;
      border-style: solid !important;
      border-width: 2px !important;
      font-family: 'Open Sans', Arial, Helvetica, sans-serif;
      font-size: 1rem !important;
      height: auto;
      line-height: 21px !important;
      margin-bottom: 0;
      margin-top: 0;
      margin-left: 0;
      margin-right: 0;
      padding: 0.75rem !important;
      width: 100% !important;
      box-sizing: border-box !important;
      max-width: 100% !important;
    }
    .dark #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input {
      background-color: #1e293b !important;
      border-color: #475569 !important;
      color: white !important;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-fieldRow input:focus {
      outline: none;
      border-color: #0EA5E9;
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit {
      margin: 0 0 20px 0;
      float: left;
      width: 100%;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button {
      background-color: #0EA5E9 !important;
      border: none !important;
      border-radius: 0.5rem !important;
      box-shadow: none !important;
      color: #ffffff !important;
      cursor: pointer;
      font-family: 'Open Sans', Arial, Helvetica, sans-serif !important;
      font-size: 1rem !important;
      font-weight: 700 !important;
      line-height: 21px !important;
      height: auto;
      padding: 0.75rem !important;
      width: 100% !important;
      box-sizing: border-box !important;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow button {
      background-color: #0EA5E9 !important;
      border: none !important;
      border-radius: 0.5rem !important;
      box-shadow: none !important;
      color: #ffffff !important;
      cursor: pointer;
      font-family: 'Open Sans', Arial, Helvetica, sans-serif !important;
      font-size: 1rem !important;
      font-weight: 700 !important;
      line-height: 21px !important;
      margin: 0 !important;
      padding: 0.75rem 1.5rem !important;
      height: auto;
      white-space: nowrap;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-horizontalRow button:hover {
      background-color: #0284c7 !important;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button.loading {
      display: none;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-embedSubmit button:hover {
      background-color: #0284c7 !important;
    }
    .ml-error input, .ml-error textarea, .ml-error select {
      border-color: red!important;
    }
    .ml-error .label-description,
    .ml-error .label-description p,
    .ml-error .label-description p a,
    .ml-error label:first-child {
      color: #ff0000 !important;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-successBody {
      display: none;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-successBody.row-success {
      display: block;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-successContent h4 {
      color: #10b981;
      font-family: 'Open Sans', Arial, Helvetica, sans-serif;
      font-size: 1.5rem;
      font-weight: 700;
      margin: 0 0 10px 0;
    }
    #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-successContent p {
      color: #64748b;
      font-family: 'Open Sans', Arial, Helvetica, sans-serif;
      font-size: 0.875rem;
      margin: 0;
    }
    .dark #mlb2-33402369.ml-form-embedContainer .ml-form-embedWrapper .ml-form-embedBody .ml-form-successContent p {
      color: #94a3b8;
    }
  </style>
  <!-- Configuration - loaded from config.js (generated at build time) -->
  <script src="config.js"></script>
</head>
<body class="bg-background-light dark:bg-background-dark font-display">
  <!-- Email Modal (MailerLite - for email collection only) -->
  <div id="email-modal" class="email-modal-overlay" style="display: none;">
    <div class="email-modal-content">
      <div id="mlb2-33402369" class="ml-form-embedContainer ml-subscribe-form ml-subscribe-form-33402369">
        <div class="ml-form-align-center">
          <div class="ml-form-embedWrapper embedForm">
            <div class="ml-form-embedBody ml-form-embedBodyHorizontal row-form">
              <div class="ml-form-embedContent">
                <h4>Welcome to Move2Japan!</h4>
                <p>Enter your email to get started!</p>
              </div>
              <form class="ml-block-form" action="https://assets.mailerlite.com/jsonp/1923093/forms/171195070484055534/subscribe" data-code="" method="post">
                <div class="ml-form-formContent horozintalForm">
                  <div class="ml-form-horizontalRow">
                    <div class="ml-input-horizontal">
                      <div style="width: 100%;" class="horizontal-fields">
                        <div class="ml-field-group ml-field-email ml-validate-email ml-validate-required">
                          <input type="email" class="form-control" data-inputmask="" name="fields[email]" placeholder="your.email@example.com" autocomplete="email" required>
                        </div>
                      </div>
                    </div>
                    <div class="ml-button-horizontal primary">
                      <button type="submit" class="primary">Continue</button>
                      <button disabled="disabled" style="display: none;" type="button" class="loading">
                        <div class="ml-form-embedSubmitLoad"></div>
                        <span class="sr-only">Loading...</span>
                      </button>
                    </div>
                  </div>
                </div>
                <input type="hidden" name="ml-submit" value="1">
                <input type="hidden" name="anticsrf" value="true">
              </form>
            </div>
            <div class="ml-form-successBody row-success" style="display: none">
              <div class="ml-form-successContent">
                <h4>Thank you!</h4>
                <p>You have successfully joined our subscriber list.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Auth Modal (Supabase Signup/Login) -->
  <div id="auth-modal" class="email-modal-overlay" style="display: none;">
    <div class="email-modal-content">
      <div style="max-width: 400px; width: 100%;">
        <div style="text-align: center; margin-bottom: 24px;">
          <h4 style="font-size: 24px; font-weight: bold; margin-bottom: 8px; color: #1e293b;">Save Your Progress</h4>
          <p style="color: #64748b;">Create an account to sync your progress across devices</p>
        </div>
        
        <!-- Tabs -->
        <div style="display: flex; gap: 8px; margin-bottom: 24px; border-bottom: 2px solid #e2e8f0;">
          <button id="auth-tab-signup" class="auth-tab active" onclick="switchAuthTab('signup')">Sign Up</button>
          <button id="auth-tab-login" class="auth-tab" onclick="switchAuthTab('login')">Log In</button>
        </div>
        
        <!-- Signup Form -->
        <div id="auth-form-signup" class="auth-form">
          <form id="signup-form" onsubmit="handleSignupSubmit(event)">
            <div style="margin-bottom: 16px;">
              <input type="email" id="signup-email" class="email-input" placeholder="your.email@example.com" autocomplete="email" required>
            </div>
            <div style="margin-bottom: 16px;">
              <input type="password" id="signup-password" class="email-input" placeholder="Password (min 6 characters)" autocomplete="new-password" required minlength="6">
            </div>
            <div style="margin-bottom: 16px;">
              <button type="submit" class="primary" style="width: 100%; padding: 12px; background: #0ea5e9; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                Sign Up
              </button>
            </div>
            <div id="signup-error" style="color: #ef4444; font-size: 14px; margin-top: 8px; display: none;"></div>
          </form>
        </div>
        
        <!-- Login Form -->
        <div id="auth-form-login" class="auth-form" style="display: none;">
          <form id="login-form" onsubmit="handleLoginSubmit(event)">
            <div style="margin-bottom: 16px;">
              <input type="email" id="login-email" class="email-input" placeholder="your.email@example.com" autocomplete="email" required>
            </div>
            <div style="margin-bottom: 16px;">
              <input type="password" id="login-password" class="email-input" placeholder="Password" autocomplete="current-password" required>
            </div>
            <div style="margin-bottom: 8px; text-align: right;">
              <a href="javascript:void(0)" onclick="handlePasswordResetRequest(document.getElementById('login-email').value || '')" style="color: #0ea5e9; font-size: 14px; text-decoration: underline;">
                Forgot password?
              </a>
            </div>
            <div style="margin-bottom: 16px;">
              <button type="submit" class="primary" style="width: 100%; padding: 12px; background: #0ea5e9; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                Log In
              </button>
            </div>
            <div id="login-error" style="color: #ef4444; font-size: 14px; margin-top: 8px; display: none;"></div>
          </form>
        </div>
        
        <div style="text-align: center; margin-top: 16px;">
          <button onclick="closeAuthModal()" style="background: none; border: none; color: #64748b; cursor: pointer; text-decoration: underline;">
            Continue without account
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="min-h-screen">
    <!-- Header -->
    <header class="relative bg-cover bg-center h-[50vh] min-h-[300px] md:h-[400px]" style="background-image: url('https://images.unsplash.com/photo-1478436127897-769e1b3f0f36?q=80&w=1170&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D');" role="img" aria-label="Beautiful landscape view of Japan with mountains and traditional architecture">
      <div class="absolute inset-0 bg-black/50"></div>
      <div class="relative z-10 mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 h-full">
        <div class="flex justify-between items-start pt-6">
          <div class="text-white font-bold text-xl">ðŸ‡¯ðŸ‡µ</div>
          <div id="auth-button-container">
            <a id="auth-button" class="rounded-lg bg-primary px-5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-sky-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-primary" href="javascript:void(0)" onclick="openAuthModal()">Save / Load</a>
          </div>
        </div>
        <div class="flex flex-col items-center justify-center h-full text-center text-white pb-16">
          <h1 class="text-4xl font-bold tracking-tight sm:text-5xl md:text-6xl">Moving to Japan Checklist</h1>
          <p class="mt-4 max-w-2xl text-lg sm:text-xl text-slate-200">A comprehensive to do guide for moving to Japan from the US</p>
        </div>
      </div>
    </header>

    <!-- Main Content -->
    <main class="pt-8 pb-20">
      <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
        <!-- Overall Progress -->
        <div class="mb-6 swipe-container">
          <div id="overall-progress-content" class="swipe-content bg-white dark:bg-slate-900 rounded-lg shadow-xl p-6 sm:p-8">
          <div class="flex justify-between items-center mb-2">
            <h2 class="text-lg font-bold text-slate-900 dark:text-white">Overall Progress</h2>
            <span id="overall-progress-percent" class="text-lg font-bold text-primary">0%</span>
          </div>
          <p id="overall-progress-text" class="text-sm text-slate-600 dark:text-slate-400 mb-4">Loading...</p>
          <div class="w-full bg-slate-200 dark:bg-slate-700 rounded-full h-3">
            <div id="overall-progress-bar" class="bg-primary h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
          </div>
          <div id="overall-progress-refresh" class="swipe-refresh">
            <span class="material-symbols-outlined">refresh</span>
          </div>
        </div>

        <!-- Two Column Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <!-- Checklist Container (Left Column - 2/3 width) -->
          <div class="lg:col-span-2">
            <div id="checklist-container" class="bg-background-light dark:bg-slate-900 rounded-lg shadow-xl p-6 sm:p-8 space-y-8">
              <div class="text-center text-slate-600 dark:text-slate-400">Loading checklist...</div>
            </div>
          </div>

          <!-- Links Column (Right Column - 1/3 width, Drawer on mobile) -->
          <div class="lg:col-span-1">
            <div id="links-container" class="fixed lg:sticky top-0 right-0 h-full lg:h-auto w-full max-w-sm lg:max-w-none bg-white dark:bg-slate-900 rounded-lg lg:rounded-lg shadow-xl lg:shadow-xl p-6 flex flex-col transform translate-x-full lg:translate-x-0 transition-transform duration-300 ease-in-out z-50" style="max-height: 100vh;">
              <!-- Drawer header with close button (mobile only) -->
              <div class="flex justify-between items-center mb-4 lg:hidden">
                <h3 class="text-lg font-bold text-slate-900 dark:text-white">Recommend Resources</h3>
                <button id="close-drawer-btn" class="text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200">
                  <span class="material-symbols-outlined">close</span>
                </button>
              </div>
              <!-- Desktop header -->
              <h3 class="text-lg font-bold text-slate-900 dark:text-white mb-4 flex-shrink-0 hidden lg:block">Resources</h3>
              <div id="links-list" class="space-y-4 overflow-y-auto flex-1">
                <p class="text-sm text-slate-500 dark:text-slate-400 text-center py-8">
                  Click on a checklist item to view related resources
                </p>
              </div>
            </div>
            <!-- Drawer overlay (mobile only) -->
            <div id="drawer-overlay" class="fixed inset-0 bg-black/50 z-40 lg:hidden hidden"></div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // Backend API configuration - loaded from config.js (generated at build time from environment variables)
    const BACKEND_API_URL = window.APP_CONFIG?.BACKEND_API_URL || 'http://localhost:8000';
    
    // Authentication state
    const AUTH_TOKEN_KEY = 'move2japan_auth_token';
    const USER_INFO_KEY = 'move2japan_user_info';
    let currentUser = null;
    let authToken = null;
    
    // Anonymous user ID storage (using localStorage to persist across sessions)
    const ANONYMOUS_USER_ID_KEY = 'move2japan_anonymous_user_id';
    // Flag to suppress email gate without associating with a user ID
    const EMAIL_GATE_SUPPRESSED_KEY = 'move2japan_email_gate_suppressed';
    
    // Initialize auth state
    function initAuthState() {
      authToken = localStorage.getItem(AUTH_TOKEN_KEY);
      const userInfo = localStorage.getItem(USER_INFO_KEY);
      if (userInfo) {
        try {
          currentUser = JSON.parse(userInfo);
        } catch (e) {
          console.error('Error parsing user info:', e);
          currentUser = null;
        }
      }
      updateAuthButton();
    }
    
    // Update auth button based on login state
    function updateAuthButton() {
      const authButton = document.getElementById('auth-button');
      const authContainer = document.getElementById('auth-button-container');
      if (authButton && authContainer) {
        if (currentUser) {
          authButton.textContent = `${currentUser.email} (Logout)`;
          authButton.onclick = handleLogout;
        } else {
          authButton.textContent = 'Save / Load';
          authButton.onclick = openAuthModal;
        }
      }
    }
    
    // Get anonymous user ID from storage
    function getAnonymousUserId() {
      return localStorage.getItem(ANONYMOUS_USER_ID_KEY);
    }
    
    // Save anonymous user ID
    function saveAnonymousUserId(userId) {
      localStorage.setItem(ANONYMOUS_USER_ID_KEY, userId);
      console.log('Saved Anonymous User ID to localStorage:', userId);
    }
    
    // Get or create anonymous user ID from backend
    async function getOrCreateAnonymousUserId() {
      // Check if we already have one
      const existingId = getAnonymousUserId();
      if (existingId) {
        console.log('Found existing Anonymous User ID:', existingId);
        return existingId;
      }
      
      console.log('No existing Anonymous User ID found, creating new one...');
      try {
        const response = await fetch(`${BACKEND_API_URL}/api/anonymous-user`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
          credentials: 'include',
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('Backend response:', data);
          const anonymousUserId = data.anonymous_user_id;
          if (anonymousUserId) {
            saveAnonymousUserId(anonymousUserId);
            console.log('Successfully created and saved Anonymous User ID:', anonymousUserId);
            return anonymousUserId;
          } else {
            console.error('Backend returned no anonymous_user_id in response');
          }
        } else {
          let errorText;
          try {
            const errorData = await response.json();
            errorText = errorData.detail || JSON.stringify(errorData);
          } catch {
            errorText = await response.text();
          }
          console.error('Failed to get anonymous user ID:', response.status, response.statusText);
          console.error('Error details:', errorText);
        }
      } catch (error) {
        console.error('Error getting anonymous user ID:', error);
      }
      
      return null;
    }
    
    // Auth modal functions
    function openAuthModal() {
      const modal = document.getElementById('auth-modal');
      if (modal) {
        modal.style.display = 'flex';
        switchAuthTab('signup');
      }
    }
    
    function closeAuthModal() {
      const modal = document.getElementById('auth-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    }
    
    function switchAuthTab(tab) {
      const signupTab = document.getElementById('auth-tab-signup');
      const loginTab = document.getElementById('auth-tab-login');
      const signupForm = document.getElementById('auth-form-signup');
      const loginForm = document.getElementById('auth-form-login');
      
      // Clear any error messages when switching tabs
      const signupError = document.getElementById('signup-error');
      const loginError = document.getElementById('login-error');
      if (signupError) {
        signupError.style.display = 'none';
        signupError.textContent = '';
      }
      if (loginError) {
        loginError.style.display = 'none';
        loginError.textContent = '';
      }
      
      if (tab === 'signup') {
        signupTab.classList.add('active');
        loginTab.classList.remove('active');
        signupForm.style.display = 'block';
        loginForm.style.display = 'none';
      } else {
        loginTab.classList.add('active');
        signupTab.classList.remove('active');
        loginForm.style.display = 'block';
        signupForm.style.display = 'none';
      }
    }
    
    // Handle password reset request
    async function handlePasswordResetRequest(email) {
      // If no email provided, prompt for it
      if (!email || email.trim() === '') {
        email = prompt('Please enter your email address to reset your password:');
        if (!email || email.trim() === '') {
          return;
        }
      }
      
      try {
        const response = await fetch(`${BACKEND_API_URL}/api/auth/password-reset`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ email: email.trim() })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          alert('Password reset email sent! Please check your inbox for instructions to reset your password.');
        } else {
          // Even if email doesn't exist, we show success message for security (don't reveal if email exists)
          alert('If an account exists with that email, a password reset link has been sent. Please check your inbox.');
        }
      } catch (error) {
        console.error('Password reset error:', error);
        alert('An error occurred. Please try again later.');
      }
    }
    
    async function handleSignupSubmit(event) {
      event.preventDefault();
      const email = document.getElementById('signup-email').value;
      const password = document.getElementById('signup-password').value;
      const errorDiv = document.getElementById('signup-error');
      
      errorDiv.style.display = 'none';
      errorDiv.textContent = '';
      
      try {
        const anonymousUserId = getAnonymousUserId();
        const localData = getCookie(COOKIE_NAME);
        const localChecklistData = localData?.checklistData || stateManager.get('checklistData');
        // Note: Completion state is now embedded in checklistData
        
        const response = await fetch(`${BACKEND_API_URL}/api/auth/signup`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            email,
            password,
            anonymous_user_id: anonymousUserId
          })
        });
        
        const data = await response.json();
        
        // Check status code - only 200/201 is success
        if (response.status === 200 || response.status === 201) {
          // Validate response data
          if (!data.user?.id || !data.user?.email) {
            errorDiv.textContent = 'Signup failed: Invalid response from server.';
            errorDiv.style.display = 'block';
            return;
          }
          
          // Save auth state
          authToken = data.access_token;
          currentUser = data.user;
          localStorage.setItem(AUTH_TOKEN_KEY, authToken);
          localStorage.setItem(USER_INFO_KEY, JSON.stringify(currentUser));
          
          updateAuthButton();
          closeAuthModal();
          
          // Migrate or load data
          if (localChecklistData && Object.keys(localChecklistData).length > 0) {
            await saveUserSiteData(localChecklistData);
          } else {
            await loadUserSiteData();
          }
          
          alert('Account created successfully! Your local progress has been saved to the cloud.');
        } else {
          // Handle error response
          const errorMessage = data.detail || 'Signup failed. Please try again.';
          const isDuplicate = response.status === 400 && (
            errorMessage.toLowerCase().includes('already') || 
            errorMessage.toLowerCase().includes('exists')
          );
          
          if (isDuplicate) {
            errorDiv.innerHTML = `
              <div style="margin-bottom: 8px;">${errorMessage}</div>
              <div style="font-size: 13px; margin-top: 8px;">
                <a href="javascript:void(0)" onclick="switchAuthTab('login')" style="color: #0ea5e9; text-decoration: underline; margin-right: 12px;">Log in instead</a>
                <a href="javascript:void(0)" onclick="handlePasswordResetRequest('${email}')" style="color: #0ea5e9; text-decoration: underline;">Reset password</a>
              </div>
            `;
          } else {
            errorDiv.textContent = errorMessage;
          }
          errorDiv.style.display = 'block';
        }
      } catch (error) {
        console.error('Signup error:', error);
        errorDiv.textContent = 'An error occurred. Please try again.';
        errorDiv.style.display = 'block';
      }
    }
    
    async function handleLoginSubmit(event) {
      event.preventDefault();
      const email = document.getElementById('login-email').value;
      const password = document.getElementById('login-password').value;
      const errorDiv = document.getElementById('login-error');
      
      errorDiv.style.display = 'none';
      errorDiv.textContent = '';
      
      try {
        // Get local data before login to potentially merge it
        const localData = getCookie(COOKIE_NAME);
        const localChecklistData = localData?.checklistData;
        
        const response = await fetch(`${BACKEND_API_URL}/api/auth/login`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            email,
            password
          })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          // Save auth token and user info
          authToken = data.access_token;
          currentUser = data.user;
          localStorage.setItem(AUTH_TOKEN_KEY, authToken);
          localStorage.setItem(USER_INFO_KEY, JSON.stringify(currentUser));
          
          updateAuthButton();
          closeAuthModal();
          
          // Load user's saved data from Supabase
          const serverData = await loadUserSiteData();
          
          // If we have local data and no server data, migrate local to server
          if (localChecklistData && Object.keys(localChecklistData).length > 0 && 
              (!serverData || !serverData.checklist_data || Object.keys(serverData.checklist_data).length === 0)) {
            await saveUserSiteData(localChecklistData);
            console.log('Migrated local data to Supabase on login');
            alert('Logged in successfully! Your local progress has been saved to the cloud.');
          } else if (serverData && serverData.checklist_data && Object.keys(serverData.checklist_data).length > 0) {
            alert('Logged in successfully! Your saved progress has been loaded.');
          } else {
            alert('Logged in successfully!');
          }
        } else {
          errorDiv.textContent = data.detail || 'Login failed. Please check your credentials.';
          errorDiv.style.display = 'block';
        }
      } catch (error) {
        console.error('Login error:', error);
        errorDiv.textContent = 'An error occurred. Please try again.';
        errorDiv.style.display = 'block';
      }
    }
    
    async function handleLogout() {
      try {
        if (authToken) {
          await fetch(`${BACKEND_API_URL}/api/auth/logout`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${authToken}`,
              'Content-Type': 'application/json',
            }
          });
        }
      } catch (error) {
        console.error('Logout error:', error);
      }
      
      // Clear auth state
      authToken = null;
      currentUser = null;
      localStorage.removeItem(AUTH_TOKEN_KEY);
      localStorage.removeItem(USER_INFO_KEY);
      
      // Clear anonymous user ID to prevent cross-user association
      // This ensures a new user on the same browser won't be linked to the previous user's anonymous ID
      localStorage.removeItem(ANONYMOUS_USER_ID_KEY);
      
      // Set flag to suppress email gate (but don't associate with a user ID)
      // This prevents the email gate from showing without creating a privacy issue
      localStorage.setItem(EMAIL_GATE_SUPPRESSED_KEY, 'true');
      
      updateAuthButton();
      
      // Reset content to initial state
      // Clear the cookie by setting it to expire in the past
      const expires = new Date();
      expires.setTime(expires.getTime() - 1);
      document.cookie = `${COOKIE_NAME}=;expires=${expires.toUTCString()};path=/;SameSite=Lax`;
      
      // Reload checklist from initial URL
      const rawChecklistData = await loadInitialChecklist();
      
      if (rawChecklistData) {
        // Normalize to new array format (this will initialize completed: false on all tasks)
        const normalized = normalizeChecklistData(rawChecklistData);
        stateManager.setState({ checklistData: normalized });
        
        // Save fresh state to cookie
        setCookie(COOKIE_NAME, {
          checklistData: normalized
        }, COOKIE_EXPIRY_DAYS);
        
        renderChecklist();
        updateOverallProgress();
      } else {
        // If loading fails, show error message
        document.getElementById('checklist-container').innerHTML = 
          '<div class="text-center text-red-600">Failed to load checklist. Please refresh the page.</div>';
      }
    }
    
    // Save user's site data to backend
    async function saveUserSiteData(checklistDataToSave) {
      if (!authToken || !currentUser) {
        console.warn('Cannot save: user not authenticated');
        return false;
      }
      
      try {
        const payload = {
          checklist_data: checklistDataToSave
        };
        
        // Log data being saved (handle both array and object formats)
        const checklistKeys = Array.isArray(checklistDataToSave) 
          ? `Array with ${checklistDataToSave.length} items` 
          : (checklistDataToSave && typeof checklistDataToSave === 'object'
              ? Object.keys(checklistDataToSave).join(', ')
              : 'unknown');
        console.log('ðŸ’¾ Saving to backend:', {
          checklistDataType: Array.isArray(checklistDataToSave) ? 'array' : typeof checklistDataToSave,
          checklistDataInfo: checklistKeys,
          userId: currentUser.id,
          payloadSize: JSON.stringify(payload).length + ' bytes'
        });
        
        const response = await fetch(`${BACKEND_API_URL}/api/site-data`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload)
        });
        
        if (response.ok) {
          const result = await response.json();
          // Log saved data (handle both array and object formats)
          const savedChecklistInfo = Array.isArray(result.checklist_data)
            ? `Array with ${result.checklist_data.length} items`
            : (result.checklist_data && typeof result.checklist_data === 'object'
                ? Object.keys(result.checklist_data).join(', ')
                : 'unknown');
          console.log('âœ… Successfully saved user site data to backend:', {
            savedChecklistInfo: savedChecklistInfo,
            updatedAt: result.updated_at
          });
          return true;
        } else {
          const errorText = await response.text();
          console.error('Failed to save user site data to backend:', {
            status: response.status,
            statusText: response.statusText,
            error: errorText
          });
          return false;
        }
      } catch (error) {
        console.error('Error saving user site data:', error);
        return false;
      }
    }
    
    // Load user's saved site data from backend
    async function loadUserSiteData() {
      if (!authToken || !currentUser) {
        console.log('Cannot load: user not authenticated');
        return null;
      }
      
      try {
        console.log('Loading user site data from backend for user:', currentUser.id);
        const response = await fetch(`${BACKEND_API_URL}/api/site-data`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json',
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          // Log loaded data (handle both array and object formats)
          const checklistInfo = data.checklist_data 
            ? (Array.isArray(data.checklist_data) 
                ? `Array with ${data.checklist_data.length} items`
                : (typeof data.checklist_data === 'object'
                    ? `${Object.keys(data.checklist_data).length} keys: ${Object.keys(data.checklist_data).join(', ')}`
                    : 'unknown'))
            : 'none';
          console.log('ðŸ“¥ Backend response received:', {
            hasChecklistData: !!data.checklist_data,
            checklistDataInfo: checklistInfo,
            checklistDataType: data.checklist_data ? (Array.isArray(data.checklist_data) ? 'array' : typeof data.checklist_data) : 'none',
            updatedAt: data.updated_at
          });
          
          // Note: Completion state is now embedded in checklist_data as 'completed' property on each task
          
          // Check if we have valid checklist data
          // Backend returns [] (empty array) or {} (empty object) when no data exists
          const hasChecklistData = data.checklist_data !== null && 
                                   data.checklist_data !== undefined &&
                                   !(Array.isArray(data.checklist_data) && data.checklist_data.length === 0) &&
                                   !(typeof data.checklist_data === 'object' && 
                                     !Array.isArray(data.checklist_data) && 
                                     Object.keys(data.checklist_data).length === 0);
          
          if (hasChecklistData) {
            // Normalize to new array format
            const normalized = normalizeChecklistData(data.checklist_data);
            stateManager.setState({ checklistData: normalized });
            
            // Check if normalized data is valid
            const hasValidData = normalized && (
              Array.isArray(normalized) 
                ? normalized.length > 0 
                : (typeof normalized === 'object' && Object.keys(normalized).length > 0)
            );
            
            if (hasValidData) {
            renderChecklist();
            updateOverallProgress();
              console.log('âœ… Successfully loaded and rendered user site data from backend');
            return data;
            } else {
              console.log('âš ï¸ Checklist data exists but is empty after normalization - will load default');
              // Clear invalid data
              stateManager.setState({ checklistData: null });
            }
          } else {
            console.log('â„¹ï¸ No checklist data found in backend response (empty or missing) - will load default');
            // Clear any invalid data
            stateManager.setState({ checklistData: null });
          }
          
          // If we get here, we have no valid checklist data, so return data to indicate successful request
          // The caller will then load the default checklist
          return data;
        } else {
          const errorText = await response.text();
          console.error('Failed to load user site data from backend:', {
            status: response.status,
            statusText: response.statusText,
            error: errorText
          });
        return null;
        }
      } catch (error) {
        console.error('Error loading user site data:', error);
        return null;
      }
    }
    
    // MailerLite success callback - called when email is submitted
    function ml_webform_success_33402369() {
      // Get anonymous user ID after successful email submission to MailerLite
      getOrCreateAnonymousUserId().then(() => {
        // Close modal after a short delay
        setTimeout(() => {
          const modal = document.getElementById('email-modal');
          if (modal) {
            modal.style.display = 'none';
          }
        }, 600);
      });
    }
    
    // Show email modal if anonymous user ID not found and email gate hasn't been suppressed
    function checkAndShowEmailModal() {
      const anonymousUserId = getAnonymousUserId();
      const emailGateSuppressed = localStorage.getItem(EMAIL_GATE_SUPPRESSED_KEY);
      
      // Only show if no anonymous user ID AND email gate hasn't been suppressed
      if (!anonymousUserId && !emailGateSuppressed) {
        const modal = document.getElementById('email-modal');
        if (modal) {
          modal.style.display = 'flex';
          // Focus on email input
          setTimeout(() => {
            const emailInput = document.querySelector('#mlb2-33402369 input[name="fields[email]"]');
            if (emailInput) {
              emailInput.focus();
            }
          }, 100);
        }
      }
    }
    
    // Initialize email modal
    function initEmailModal() {
      // Check if we should show the email modal FIRST (before creating anonymous user ID)
      const anonymousUserId = getAnonymousUserId();
      const emailGateSuppressed = localStorage.getItem(EMAIL_GATE_SUPPRESSED_KEY);
      
      // If no anonymous user ID exists AND email gate hasn't been suppressed, show the email modal
      if (!anonymousUserId && !emailGateSuppressed) {
        checkAndShowEmailModal();
      }
      
      // Intercept form submission to create anonymous user ID when email is submitted
      const mailerLiteForm = document.querySelector('#mlb2-33402369 form.ml-block-form');
      if (mailerLiteForm) {
        mailerLiteForm.addEventListener('submit', async function(e) {
          // Create anonymous user ID when form is submitted to MailerLite
          // This ID will be used for local storage
          await getOrCreateAnonymousUserId();
        }, { once: true }); // Only listen once
      }
    }
    
    // Note: We do NOT create anonymous user ID on page load
    // It should only be created when:
    // 1. User submits email to MailerLite (via initEmailModal)
    // 2. User interacts with the site and we need to track them
    
    // Cookie management
    const COOKIE_NAME = 'japan_checklist_data';
    const COOKIE_EXPIRY_DAYS = 365;

    function setCookie(name, value, days) {
      const expires = new Date();
      expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
      // Use SameSite=Lax for better compatibility (works for same-site and most cross-site scenarios)
      document.cookie = `${name}=${encodeURIComponent(JSON.stringify(value))};expires=${expires.toUTCString()};path=/;SameSite=Lax`;
    }

    function getCookie(name) {
      const nameEQ = name + "=";
      const ca = document.cookie.split(';');
      for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) === 0) {
          try {
            return JSON.parse(decodeURIComponent(c.substring(nameEQ.length, c.length)));
          } catch (e) {
            return null;
          }
        }
      }
      return null;
    }

    // Initialize Application Modules
    const dataManager = new ChecklistDataManager(stateManager);
    const dragDropManager = new DragDropManager(dataManager, (type, ...args) => {
      // Callback when reordering happens
      saveProgress();
      renderChecklist();
    });
    const taskRenderer = new TaskRenderer(dataManager, dragDropManager, {
      onToggle: (categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex) => {
        dataManager.toggleTask(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex);
        saveProgress();
        updateOverallProgress();
        updateCategoryProgress(categoryIndex, phaseIndex);
        const subcategoryCheckbox = document.querySelector(
          `[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"][data-subcategory-index="${subcategoryIndex}"] input[type="checkbox"]`
        );
        if (subcategoryCheckbox) {
          updateSubcategoryCheckboxState(categoryIndex, phaseIndex, subcategoryIndex, subcategoryCheckbox);
        }
        const phaseCheckbox = document.querySelector(
          `[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"] input[type="checkbox"]`
        );
        if (phaseCheckbox) {
          updatePhaseCheckboxState(categoryIndex, phaseIndex, phaseCheckbox);
        }
      },
      onEdit: (categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex) => {
        // Handled in TaskRenderer
      },
      onDelete: (categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex, swipeContainer) => {
        deleteTask(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex, swipeContainer);
      },
      onShowLinks: (links, taskName, row) => {
        showTaskLinks(links, taskName, row);
      },
      addSwipeHandlers: (row, container) => {
        addSwipeHandlers(row, container);
      },
      onSave: () => {
        saveProgress();
      }
    });
    const subcategoryRenderer = new SubcategoryRenderer(dataManager, dragDropManager, taskRenderer, {
      onToggleSubcategory: (categoryIndex, phaseIndex, subcategoryIndex, checked) => {
        dataManager.setSubcategoryTasksCompleted(categoryIndex, phaseIndex, subcategoryIndex, checked);
        saveProgress();
        updateOverallProgress();
        updateCategoryProgress(categoryIndex, phaseIndex);
        const phaseCheckbox = document.querySelector(
          `[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"] input[type="checkbox"]`
        );
        if (phaseCheckbox) {
          updatePhaseCheckboxState(categoryIndex, phaseIndex, phaseCheckbox);
        }
      },
      onEditSubcategory: (categoryIndex, phaseIndex, subcategoryIndex, newTitle, oldTitle) => {
        const { subcategories } = dataManager.getPhaseData(categoryIndex, phaseIndex);
        if (subcategories && subcategories[subcategoryIndex]) {
          const oldSubcategoryObj = subcategories[subcategoryIndex];
          const oldSubcategoryName = Object.keys(oldSubcategoryObj)[0];
          const subcategoryData = oldSubcategoryObj[oldSubcategoryName];
          subcategories[subcategoryIndex] = { [newTitle]: subcategoryData };
          saveProgress();
          updateOverallProgress();
          updateCategoryProgress(categoryIndex, phaseIndex);
        }
      },
      onDeleteSubcategory: (categoryIndex, phaseIndex, subcategoryIndex, element) => {
        deleteSubSection(categoryIndex, phaseIndex, subcategoryIndex, element);
      },
      onAddTask: (categoryIndex, phaseIndex, subcategoryIndex, container, parent) => {
        showAddTaskDialog(categoryIndex, phaseIndex, subcategoryIndex, container, parent);
      },
      updateSubcategoryCheckbox: (categoryIndex, phaseIndex, subcategoryIndex, checkbox) => {
        updateSubcategoryCheckboxState(categoryIndex, phaseIndex, subcategoryIndex, checkbox);
      },
      addSwipeHandlers: (element, container) => {
        addSwipeHandlers(element, container);
      }
    });
    const phaseRenderer = new PhaseRenderer(dataManager, dragDropManager, subcategoryRenderer, {
      onTogglePhase: (categoryIndex, phaseIndex, checked) => {
        dataManager.setPhaseTasksCompleted(categoryIndex, phaseIndex, checked);
        saveProgress();
        updateOverallProgress();
        updateCategoryProgress(categoryIndex, phaseIndex);
      },
      onEditPhase: (categoryIndex, phaseIndex, newTitle, oldTitle) => {
        const { phases } = dataManager.getCategoryData(categoryIndex);
        if (phases && phases[phaseIndex]) {
          const oldPhaseObj = phases[phaseIndex];
          const oldPhaseName = Object.keys(oldPhaseObj)[0];
          const phaseData = oldPhaseObj[oldPhaseName];
          phases[phaseIndex] = { [newTitle]: phaseData };
          saveProgress();
          updateOverallProgress();
          updateCategoryProgress(categoryIndex, phaseIndex);
        }
      },
      onDeletePhase: (categoryIndex, phaseIndex, element) => {
        deletePhase(categoryIndex, phaseIndex, element);
      },
      onAddCategory: (categoryIndex, phaseIndex, container) => {
        addNewCategory(categoryIndex, phaseIndex, container);
      },
      updateCategoryProgress: (categoryIndex, phaseIndex) => {
        updateCategoryProgress(categoryIndex, phaseIndex);
      },
      updatePhaseCheckbox: (categoryIndex, phaseIndex, checkbox) => {
        updatePhaseCheckboxState(categoryIndex, phaseIndex, checkbox);
      },
      addSwipeHandlers: (element, container) => {
        addSwipeHandlers(element, container);
      }
    });
    
    // Initialize state manager with auth state
    stateManager.setState({
      authToken: localStorage.getItem(AUTH_TOKEN_KEY),
      currentUser: (() => {
        const userInfo = localStorage.getItem(USER_INFO_KEY);
        if (userInfo) {
          try {
            return JSON.parse(userInfo);
          } catch (e) {
            return null;
          }
        }
        return null;
      })(),
      anonymousUserId: localStorage.getItem(ANONYMOUS_USER_ID_KEY),
      emailGateSuppressed: !!localStorage.getItem(EMAIL_GATE_SUPPRESSED_KEY)
    });
    
    // Subscribe to state changes to update local variables for backwards compatibility
    stateManager.subscribe((prevState, newState) => {
      if (newState.authToken !== prevState.authToken) {
        authToken = newState.authToken;
      }
      if (newState.currentUser !== prevState.currentUser) {
        currentUser = newState.currentUser;
      }
    });
    
    let swipeCloseHandlerAdded = false;
    
    // Default URL for checklist JSON
    const DEFAULT_CHECKLIST_URL = 'https://gist.githubusercontent.com/jalakoo/35757f63df6ddc71f6cf8e31acd5c5bd/raw/move2japan_initial_config.json';
    
    // Recursively initialize completed property on all task objects
    function initializeCompletedProperty(data) {
      if (!data) return;
      
      if (Array.isArray(data)) {
        data.forEach(item => {
          if (isTaskObject(item)) {
            // Initialize completed property if not already set
            if (item.completed === undefined) {
              item.completed = false;
            }
            // Recursively process nested arrays (for subtasks)
            Object.values(item).forEach(value => {
              if (Array.isArray(value)) {
                initializeCompletedProperty(value);
              }
            });
          } else if (typeof item === 'object' && item !== null) {
            // It's a container, recursively process its values
            Object.values(item).forEach(value => {
              if (Array.isArray(value)) {
                initializeCompletedProperty(value);
              }
            });
          }
        });
      } else if (typeof data === 'object' && data !== null) {
        Object.values(data).forEach(value => {
          if (Array.isArray(value)) {
            initializeCompletedProperty(value);
          }
        });
      }
    }
    
    // Normalize checklist data to new array-based format
    function normalizeChecklistData(data) {
      if (!data) return null;
      
      let normalized;
      
      // If already in new format (array), normalize it
      if (Array.isArray(data)) {
        normalized = [];
        data.forEach(categoryObj => {
          const categoryName = Object.keys(categoryObj)[0];
          const phasesArray = categoryObj[categoryName];
          
          if (!Array.isArray(phasesArray)) {
            // Already normalized, return as-is
            normalized.push(categoryObj);
            return;
          }
          
          // Check if phases array contains one object with multiple phase keys
          // or multiple objects each with one phase key
          const normalizedPhases = [];
          
          phasesArray.forEach(phaseItem => {
            if (typeof phaseItem === 'object' && phaseItem !== null) {
              const phaseKeys = Object.keys(phaseItem);
              
              // If this object has multiple phase keys, split them into separate phase objects
              phaseKeys.forEach(phaseName => {
                const phaseData = phaseItem[phaseName];
                normalizedPhases.push({
                  [phaseName]: phaseData
                });
              });
            }
          });
          
          normalized.push({
            [categoryName]: normalizedPhases
          });
        });
      } else {
        // Convert old object-based format to new array-based format
        normalized = [];
        for (const categoryName in data) {
          const categoryObj = data[categoryName];
          const phases = [];
          
          for (const phaseName in categoryObj) {
            const phaseObj = categoryObj[phaseName];
            const subcategories = [];
            
            for (const subcategoryName in phaseObj) {
              subcategories.push({
                [subcategoryName]: phaseObj[subcategoryName]
              });
            }
            
            phases.push({
              [phaseName]: subcategories
            });
          }
          
          normalized.push({
            [categoryName]: phases
          });
        }
      }
      
      // Initialize completed property on all tasks
      initializeCompletedProperty(normalized);
      
      return normalized;
    }
    
    // Helper functions - now use dataManager
    function getCategoryData(categoryIndex) {
      return dataManager.getCategoryData(categoryIndex) || { name: null, phases: null };
    }
    
    function getPhaseData(categoryIndex, phaseIndex) {
      return dataManager.getPhaseData(categoryIndex, phaseIndex) || { name: null, subcategories: null };
    }
    
    function getSubcategoryData(categoryIndex, phaseIndex, subcategoryIndex) {
      return dataManager.getSubcategoryData(categoryIndex, phaseIndex, subcategoryIndex) || { name: null, items: null };
    }
    
    function getTaskObject(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex = null) {
      return dataManager.getTaskObject(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex);
    }
    
    function isTaskObject(obj) {
      return dataManager.isTaskObject(obj);
    }

    // Load initial checklist from JSON URL
    async function loadInitialChecklist() {
      // Get URL from query parameter or use default
      const urlParams = new URLSearchParams(window.location.search);
      const checklistUrl = urlParams.get('checklist_url') || DEFAULT_CHECKLIST_URL;
      
      try {
        const response = await fetch(checklistUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error loading checklist from URL:', error);
        return null;
      }
    }

    // Reset checklist to original state
    async function resetChecklist() {
      // Clear the cookie by setting it to expire in the past
      const expires = new Date();
      expires.setTime(expires.getTime() - 1);
      document.cookie = `${COOKIE_NAME}=;expires=${expires.toUTCString()};path=/;SameSite=Lax`;
      
      // Reload checklist from DEFAULT_CHECKLIST_URL
      const rawChecklistData = await loadInitialChecklist();
      
      if (rawChecklistData) {
        // Normalize to new array format (this will initialize completed: false on all tasks)
        const normalized = normalizeChecklistData(rawChecklistData);
        stateManager.setState({ checklistData: normalized });
        
        // Save fresh state to cookie
        setCookie(COOKIE_NAME, {
          checklistData: normalized
        }, COOKIE_EXPIRY_DAYS);
        
        // Re-render the checklist
        renderChecklist();
        updateOverallProgress();
        
        console.log('Checklist reset to original state');
      } else {
        console.error('Failed to reload checklist');
        alert('Failed to reload checklist. Please refresh the page.');
      }
    }

    // Initialize app
    async function init() {
      // Initialize auth state
      initAuthState();
      
      // Check if user has visited before and has saved progress (from cookie)
      const savedData = getCookie(COOKIE_NAME);
      
      // If user is logged in, try to load their data from backend first
      if (authToken && currentUser) {
        const serverData = await loadUserSiteData();
        // If we got valid checklist data from server, use it (it's already loaded and rendered in loadUserSiteData)
        const checklistData = stateManager.get('checklistData');
        if (checklistData && (
          Array.isArray(checklistData) ? checklistData.length > 0 : Object.keys(checklistData).length > 0
        )) {
          // Data already loaded and rendered by loadUserSiteData
          // Completion state is embedded in checklistData
          wireUpOverallProgressSwipe();
          return;
        }
        // This handles the case where logged-in user has no saved checklist - use default
        console.log('No valid checklist data from server, will load default checklist');
      }
      
      // Always load the latest checklist from URL (in case it was updated)
      // But only if we don't already have valid checklistData from server
      const currentChecklistData = stateManager.get('checklistData');
      if (!currentChecklistData) {
        let rawChecklistData = await loadInitialChecklist();
        
        if (rawChecklistData) {
          // Normalize to new array format (this will initialize completed: false on all tasks)
          const normalized = normalizeChecklistData(rawChecklistData);
          stateManager.setState({ checklistData: normalized });
          
          // If user is logged in and we just loaded default checklist, save it to backend
          if (authToken && currentUser) {
            // Save the default checklist to backend so user has it saved
            setTimeout(async () => {
              try {
                await saveUserSiteData(normalized);
                console.log('âœ… Saved default checklist to backend for user');
              } catch (error) {
                console.error('Failed to save default checklist to backend:', error);
              }
            }, 1000); // Small delay to ensure page is loaded
          }
          
          // Save current state to cookie (with latest checklist data)
          // Completion state is embedded in checklistData
        setCookie(COOKIE_NAME, {
            checklistData: normalized
        }, COOKIE_EXPIRY_DAYS);
        
        renderChecklist();
        updateOverallProgress();
      } else {
        // If loading fails, try to use saved data as fallback
        if (savedData && savedData.checklistData) {
            // Normalize saved data to new format
            const normalized = normalizeChecklistData(savedData.checklistData);
            stateManager.setState({ checklistData: normalized });
          renderChecklist();
          updateOverallProgress();
        } else {
          document.getElementById('checklist-container').innerHTML = 
            '<div class="text-center text-red-600">Failed to load checklist. Please refresh the page.</div>';
          }
        }
      }
      
      // Wire up Overall Progress swipe and refresh button
      wireUpOverallProgressSwipe();
    }

    // Count all tasks recursively (new dynamic format)
    function countAllTasks(data) {
      if (!data || !Array.isArray(data)) return 0;
      
      const taskObjects = [];
      dataManager.collectTasksFromArray(data, taskObjects);
      return taskObjects.length;
    }

    // Check if task is completed (by checking the task object's completed property)
    function isTaskCompleted(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex = null) {
      const task = getTaskObject(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex);
      return task ? (task.completed === true) : false;
    }

    // Toggle task completion (by updating the task object's completed property)
    function toggleTask(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex = null) {
      // This is now handled by TaskRenderer callbacks, but kept for backwards compatibility
      const task = getTaskObject(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex);
      if (!task) return;
      
      dataManager.toggleTask(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex);
      saveProgress();
      updateOverallProgress();
      
      // Update subcategory checkbox
      const subcategoryCheckbox = document.querySelector(
        `[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"][data-subcategory-index="${subcategoryIndex}"] input[type="checkbox"]`
      );
      if (subcategoryCheckbox) {
        updateSubcategoryCheckboxState(categoryIndex, phaseIndex, subcategoryIndex, subcategoryCheckbox);
      }
      
      // Update phase checkbox
      const phaseCheckbox = document.querySelector(
        `[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"] input[type="checkbox"]`
      );
          if (phaseCheckbox) {
        updatePhaseCheckboxState(categoryIndex, phaseIndex, phaseCheckbox);
      }
      
      // Update category progress
      updateCategoryProgress(categoryIndex, phaseIndex);
    }

    // Toggle all tasks in a phase (new dynamic format)
    function togglePhaseTasks(categoryIndex, phaseIndex, checked) {
      dataManager.setPhaseTasksCompleted(categoryIndex, phaseIndex, checked);
      
      // Update UI for all affected task rows
      const checklistData = stateManager.get('checklistData');
      if (checklistData) {
        const taskObjects = [];
        dataManager.collectTasksFromArray(dataManager.getPhaseData(categoryIndex, phaseIndex).subcategories, taskObjects);
        
        taskObjects.forEach((task) => {
          const rows = document.querySelectorAll('.flex.items-center');
          rows.forEach(row => {
            const label = row.querySelector('span[data-task-name]');
            if (label && label.textContent.trim() === task.name) {
              const checkbox = row.querySelector('input[type="checkbox"]');
              if (checkbox) {
                checkbox.checked = checked;
                if (label) {
                  if (checked) {
                    label.classList.add('strikethrough');
                  } else {
                    label.classList.remove('strikethrough');
                  }
                }
              }
            }
          });
        });
      }

      saveProgress();
      updateOverallProgress();
      updateCategoryProgress(categoryIndex, phaseIndex);
    }
    
    // Toggle all tasks in a subcategory (recursively)
    function toggleSubcategoryTasks(categoryIndex, phaseIndex, subcategoryIndex, checked) {
      dataManager.setSubcategoryTasksCompleted(categoryIndex, phaseIndex, subcategoryIndex, checked);

      // Update UI for all affected task rows
      const { items } = getSubcategoryData(categoryIndex, phaseIndex, subcategoryIndex);
      if (items) {
        const taskObjects = [];
        dataManager.collectTasksFromArray(items, taskObjects);
        
        taskObjects.forEach((task) => {
          const rows = document.querySelectorAll('.flex.items-center');
          rows.forEach(row => {
            const label = row.querySelector('span[data-task-name]');
            if (label && label.textContent.trim() === task.name) {
            const checkbox = row.querySelector('input[type="checkbox"]');
            if (checkbox) {
              checkbox.checked = checked;
              if (label) {
                if (checked) {
                  label.classList.add('strikethrough');
                } else {
                  label.classList.remove('strikethrough');
              }
            }
          }
        }
      });
        });
      }
      
      // Update phase checkbox state (since subcategory changed)
      const phaseCheckbox = document.querySelector(
        `[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"] input[type="checkbox"]`
      );
      if (phaseCheckbox) {
        updatePhaseCheckboxState(categoryIndex, phaseIndex, phaseCheckbox);
      }
      
      // Save immediately to local storage
      saveProgress();
      updateOverallProgress();
      updateCategoryProgress(categoryIndex, phaseIndex);
    }
    
    // Update subcategory checkbox state based on task completion
    function updateSubcategoryCheckboxState(categoryIndex, phaseIndex, subcategoryIndex, subcategoryCheckbox) {
      const counts = dataManager.countSubcategoryTasks(categoryIndex, phaseIndex, subcategoryIndex);
      const { completed, total } = counts;
      
      // Set checkbox state
      if (total === 0) {
        subcategoryCheckbox.checked = false;
        subcategoryCheckbox.indeterminate = false;
      } else if (completed === total) {
        subcategoryCheckbox.checked = true;
        subcategoryCheckbox.indeterminate = false;
      } else if (completed > 0) {
        subcategoryCheckbox.checked = false;
        subcategoryCheckbox.indeterminate = true;
      } else {
        subcategoryCheckbox.checked = false;
        subcategoryCheckbox.indeterminate = false;
      }
    }

    // Update phase checkbox state based on task completion (new dynamic format)
    function updatePhaseCheckboxState(categoryIndex, phaseIndex, phaseCheckbox) {
      const { subcategories } = getPhaseData(categoryIndex, phaseIndex);
      if (!subcategories) return;
      
      let totalTasks = 0;
      let completedCount = 0;

      function countTasksInArray(arr) {
        if (!Array.isArray(arr)) return;
        
        arr.forEach((item) => {
          if (isTaskObject(item)) {
            totalTasks++;
            if (item.completed === true) {
              completedCount++;
            }

            // Check for nested tasks
            Object.values(item).forEach(value => {
              if (Array.isArray(value)) {
                value.forEach((subItem) => {
                  if (isTaskObject(subItem)) {
                totalTasks++;
                    if (subItem.completed === true) {
                  completedCount++;
                    }
                }
              });
            }
          });
          } else if (typeof item === 'object' && item !== null) {
            // Nested container - recursively process
            Object.values(item).forEach(value => {
              if (Array.isArray(value)) {
                countTasksInArray(value);
              }
            });
          }
        });
      }

      // Count all tasks in this phase
      subcategories.forEach((subcategoryObj, subcategoryIndex) => {
        const subcategoryName = Object.keys(subcategoryObj)[0];
        const subcategory = subcategoryObj[subcategoryName];
        if (Array.isArray(subcategory)) {
          countTasksInArray(subcategory, subcategoryIndex);
        }
      });

      // Set checkbox state: checked if all tasks are completed, indeterminate if some are completed
      if (totalTasks === 0) {
        phaseCheckbox.checked = false;
        phaseCheckbox.indeterminate = false;
      } else if (completedCount === totalTasks) {
        phaseCheckbox.checked = true;
        phaseCheckbox.indeterminate = false;
      } else if (completedCount > 0) {
        phaseCheckbox.checked = false;
        phaseCheckbox.indeterminate = true;
      } else {
        phaseCheckbox.checked = false;
        phaseCheckbox.indeterminate = false;
      }
    }

    // Save progress to cookie and/or backend
    async function saveProgress() {
      const checklistData = stateManager.get('checklistData');
      if (!checklistData) {
        console.warn('Cannot save progress: checklistData is not loaded');
        return;
      }
      
      // If no anonymous user ID exists yet, create one when user interacts with the site
      // This handles the case where user interacts before submitting email
      if (!getAnonymousUserId()) {
        await getOrCreateAnonymousUserId();
      }
      
      // IMMEDIATELY save to localStorage/cookie for instant local persistence
      // Note: Completion state is now embedded in checklistData as 'completed' property on each task
      setCookie(COOKIE_NAME, {
        checklistData: checklistData
      }, COOKIE_EXPIRY_DAYS);
      
      // Also save to localStorage for faster access
      try {
        localStorage.setItem(COOKIE_NAME, JSON.stringify({
          checklistData: checklistData
        }));
      } catch (e) {
        console.warn('Could not save to localStorage:', e);
      }
      
      console.log('Saved checklist data to local storage (completion state embedded in tasks)');
      
      // Then save to backend asynchronously (don't await - fire and forget for better UX)
      const authToken = stateManager.get('authToken');
      const currentUser = stateManager.get('currentUser');
      if (authToken && currentUser) {
        // Use setTimeout to debounce rapid changes, but ensure it eventually saves
        if (saveProgress.backendSaveTimeout) {
          clearTimeout(saveProgress.backendSaveTimeout);
        }
        saveProgress.backendSaveTimeout = setTimeout(async () => {
          try {
            // Validate checklistData before saving
            if (!checklistData) {
              console.warn('âš ï¸ Cannot save: checklistData is null or undefined');
              return;
            }
            
            // Deep clone to ensure we're saving the current state
            const dataToSave = JSON.parse(JSON.stringify(checklistData));
            
            const checklistDataLength = Array.isArray(dataToSave) 
              ? dataToSave.length 
              : (dataToSave && typeof dataToSave === 'object' ? Object.keys(dataToSave).length : 0);
            console.log('ðŸ”„ Attempting to save to backend...', {
              checklistDataType: Array.isArray(dataToSave) ? 'array' : typeof dataToSave,
              checklistDataLength: checklistDataLength,
              dataSize: JSON.stringify(dataToSave).length + ' bytes'
            });
            const success = await saveUserSiteData(dataToSave);
            if (success) {
              console.log('âœ… Saved to backend successfully');
            } else {
              console.error('âŒ Failed to save to backend (check console for details)');
            }
          } catch (error) {
            console.error('âŒ Error saving to backend:', error);
            // Could show a notification here if desired
          }
        }, 500); // Debounce by 500ms
        
        // Also save immediately on page unload to ensure data isn't lost
        if (!saveProgress.unloadHandlerAdded) {
          // Use visibilitychange and beforeunload for more reliable saves
          const performUnloadSave = () => {
            // Clear any pending timeout and save immediately (synchronously if possible)
            if (saveProgress.backendSaveTimeout) {
              clearTimeout(saveProgress.backendSaveTimeout);
              saveProgress.backendSaveTimeout = null;
            }
            // Force immediate save (fire and forget - won't block unload)
            const currentChecklistData = stateManager.get('checklistData');
            if (currentChecklistData) {
              const dataToSave = JSON.parse(JSON.stringify(currentChecklistData));
              saveUserSiteData(dataToSave).catch(err => {
                console.error('Failed to save on unload:', err);
              });
            }
          };
          
          // Save when page becomes hidden (more reliable than beforeunload)
          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
              performUnloadSave();
            }
          });
          
          // Also try on beforeunload as backup
          window.addEventListener('beforeunload', performUnloadSave);
          
          saveProgress.unloadHandlerAdded = true;
        }
      }
    }

    // Render checklist (new array format)
    function renderChecklist() {
      const container = document.getElementById('checklist-container');
      container.innerHTML = '';

      const checklistData = stateManager.get('checklistData');
      if (!checklistData || !Array.isArray(checklistData) || checklistData.length === 0) {
        container.innerHTML = '<div class="text-center text-red-600">No checklist data available.</div>';
        return;
      }

      // For now, we'll work with the first category (can be extended later)
      const categoryIndex = 0;
      const category = dataManager.getCategoryData(categoryIndex);
      if (!category || !category.phases || category.phases.length === 0) {
        container.innerHTML = '<div class="text-center text-red-600">No phases available.</div>';
        return;
      }

      let isFirstPhase = true;
      category.phases.forEach((phaseObj, phaseIndex) => {
        const phaseName = Object.keys(phaseObj)[0];
        const phase = phaseObj[phaseName];
        const categoryElement = phaseRenderer.createPhaseElement(phaseName, phase, categoryIndex, phaseIndex, isFirstPhase);
        container.appendChild(categoryElement);
        isFirstPhase = false;
      });
      
      // Add "+ Phase" button at the bottom
      const addPhaseButton = document.createElement('button');
      addPhaseButton.className = 'add-button w-full';
      addPhaseButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Phase</span>';
      addPhaseButton.onclick = () => addNewPhase(categoryIndex);
      container.appendChild(addPhaseButton);
    }

    // Legacy function - now uses phaseRenderer
    function createCategoryElement(phaseName, phase, categoryIndex, phaseIndex, isFirstPhase = true) {
      return phaseRenderer.createPhaseElement(phaseName, phase, categoryIndex, phaseIndex, isFirstPhase);
    }
    
    // Setup drag and drop for phases
    function setupPhaseDragAndDrop(element, categoryIndex, phaseIndex) {
      element.addEventListener('dragstart', (e) => {
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', JSON.stringify({ categoryIndex, phaseIndex }));
        element.classList.add('dragging');
      });
      
      element.addEventListener('dragend', (e) => {
        element.classList.remove('dragging');
        document.querySelectorAll('.draggable-phase').forEach(el => {
          el.classList.remove('drag-over');
        });
      });
      
      element.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        // Add visual feedback
        if (!element.classList.contains('dragging')) {
          element.classList.add('drag-over');
        }
      });
      
      element.addEventListener('dragleave', (e) => {
        element.classList.remove('drag-over');
      });
      
      element.addEventListener('drop', (e) => {
        e.preventDefault();
        element.classList.remove('drag-over');
        
        try {
          const data = JSON.parse(e.dataTransfer.getData('text/plain'));
          const sourceCategoryIndex = data.categoryIndex;
          const sourcePhaseIndex = data.phaseIndex;
          const targetCategoryIndex = parseInt(element.dataset.categoryIndex);
          const targetPhaseIndex = parseInt(element.dataset.phaseIndex);
          
          if (sourceCategoryIndex === targetCategoryIndex && sourcePhaseIndex !== targetPhaseIndex) {
            // Find the new index based on DOM position
            const container = element.parentElement;
            const allPhases = Array.from(container.querySelectorAll('.draggable-phase'));
            const draggedElement = document.querySelector('.dragging');
            const targetIndex = Array.from(container.children).indexOf(element);
            const sourceIndex = Array.from(container.children).indexOf(draggedElement);
            
            // Update DOM first for visual feedback
            if (targetIndex < sourceIndex) {
              container.insertBefore(draggedElement, element);
            } else {
              container.insertBefore(draggedElement, element.nextSibling);
            }
            
            // Then update data structure
            reorderPhase(targetCategoryIndex, sourcePhaseIndex, targetPhaseIndex);
          }
        } catch (error) {
          console.error('Error parsing drag data:', error);
        }
      });
    }
    
    // Get element after which to insert dragged element
    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.draggable-phase:not(.dragging)')];
      
      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
    
    // Reorder phase in data structure
    function reorderPhase(categoryIndex, fromIndex, toIndex) {
      if (dataManager.reorderPhase(categoryIndex, fromIndex, toIndex)) {
        saveProgress();
        renderChecklist();
      }
    }
    
    // Old drag-and-drop setup functions removed - now handled by DragDropManager
    // setupSubcategoryDragAndDrop, setupTaskDragAndDrop, setupTaskContainerDragAndDrop, setupPhaseDragAndDrop
    // are now handled by dragDropManager
    
    // Legacy function for backwards compatibility - now uses dragDropManager
    function setupSubcategoryDragAndDrop(element, categoryIndex, phaseIndex, subcategoryIndex) {
      dragDropManager.setupSubcategoryDragAndDrop(element, categoryIndex, phaseIndex, subcategoryIndex);
    }
    
    function setupTaskContainerDragAndDrop(container, categoryIndex, phaseIndex, subcategoryIndex) {
      dragDropManager.setupTaskContainerDragAndDrop(container, categoryIndex, phaseIndex, subcategoryIndex);
    }
    
    function setupTaskDragAndDrop(element, categoryIndex, phaseIndex, subcategoryIndex, taskIndex) {
      dragDropManager.setupTaskDragAndDrop(element, categoryIndex, phaseIndex, subcategoryIndex, taskIndex);
    }
    
    function setupPhaseDragAndDrop(element, categoryIndex, phaseIndex) {
      dragDropManager.setupPhaseDragAndDrop(element, categoryIndex, phaseIndex);
    }
    
    // Reorder subcategory in data structure
    function reorderSubcategory(categoryIndex, phaseIndex, fromIndex, toIndex) {
      if (dataManager.reorderSubcategory(categoryIndex, phaseIndex, fromIndex, toIndex)) {
        saveProgress();
        renderChecklist();
      }
    }
    
    // Setup drag and drop for tasks container (handles drops on empty space)
    function setupTaskContainerDragAndDrop(container, categoryIndex, phaseIndex, subcategoryIndex) {
      container.addEventListener('dragover', (e) => {
        // Only handle if dragging a task from the same subcategory
        try {
          const dragData = e.dataTransfer.getData('text/plain');
          if (!dragData) {
            // Try to get it from the drag event
            const items = e.dataTransfer.items;
            if (items && items.length > 0) {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'move';
            }
            return;
          }
          
          const data = JSON.parse(dragData);
          if (data.categoryIndex === categoryIndex && 
              data.phaseIndex === phaseIndex && 
              data.subcategoryIndex === subcategoryIndex) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
          }
        } catch (error) {
          // Ignore parse errors, but still allow drop
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        }
      });
      
      container.addEventListener('drop', (e) => {
        e.preventDefault();
        
        try {
          const data = JSON.parse(e.dataTransfer.getData('text/plain'));
          const sourceCategoryIndex = data.categoryIndex;
          const sourcePhaseIndex = data.phaseIndex;
          const sourceSubcategoryIndex = data.subcategoryIndex;
          const sourceTaskIndex = data.taskIndex;
          
          // Find the task row that was dropped on (or the last task if dropped on empty space)
          const taskRows = Array.from(container.querySelectorAll('.draggable-task'));
          let targetTaskIndex = taskRows.length; // Default to last position (after all tasks)
          
          // Try to find which task row was dropped on based on Y position
          for (let i = 0; i < taskRows.length; i++) {
            const rect = taskRows[i].getBoundingClientRect();
            const midPoint = rect.top + (rect.height / 2);
            if (e.clientY <= midPoint) {
              targetTaskIndex = parseInt(taskRows[i].dataset.taskIndex);
              break;
            }
            if (i === taskRows.length - 1) {
              // Dropped after last task
              targetTaskIndex = parseInt(taskRows[i].dataset.taskIndex) + 1;
            }
          }
          
          if (sourceCategoryIndex === categoryIndex && 
              sourcePhaseIndex === phaseIndex && 
              sourceSubcategoryIndex === subcategoryIndex && 
              sourceTaskIndex !== targetTaskIndex) {
            reorderTask(categoryIndex, phaseIndex, subcategoryIndex, sourceTaskIndex, targetTaskIndex);
          }
        } catch (error) {
          console.error('Error handling container drop:', error);
        }
      });
    }
    
    // Setup drag and drop for tasks (called from createTaskRow)
    function setupTaskDragAndDrop(element, categoryIndex, phaseIndex, subcategoryIndex, taskIndex) {
      element.addEventListener('dragstart', (e) => {
        // Only allow drag from the drag handle
        if (e.target.classList.contains('drag-handle') || e.target.closest('.drag-handle')) {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', JSON.stringify({ categoryIndex, phaseIndex, subcategoryIndex, taskIndex }));
          element.classList.add('dragging');
        } else {
          e.preventDefault();
        }
      });
      
      element.addEventListener('dragend', (e) => {
        element.classList.remove('dragging');
        // Remove drag-over class from all task rows
        document.querySelectorAll('.draggable-task').forEach(el => {
          el.classList.remove('drag-over');
        });
      });
      
      element.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        // Add visual feedback
        if (!element.classList.contains('dragging')) {
          element.classList.add('drag-over');
        }
      });
      
      element.addEventListener('dragleave', (e) => {
        element.classList.remove('drag-over');
      });
      
      element.addEventListener('drop', (e) => {
        e.preventDefault();
        element.classList.remove('drag-over');
        
        try {
          const data = JSON.parse(e.dataTransfer.getData('text/plain'));
          const sourceCategoryIndex = data.categoryIndex;
          const sourcePhaseIndex = data.phaseIndex;
          const sourceSubcategoryIndex = data.subcategoryIndex;
          const sourceTaskIndex = data.taskIndex;
          const targetCategoryIndex = parseInt(element.dataset.categoryIndex);
          const targetPhaseIndex = parseInt(element.dataset.phaseIndex);
          const targetSubcategoryIndex = parseInt(element.dataset.subcategoryIndex);
          const targetTaskIndex = parseInt(element.dataset.taskIndex);
          
          if (sourceCategoryIndex === targetCategoryIndex && 
              sourcePhaseIndex === targetPhaseIndex && 
              sourceSubcategoryIndex === targetSubcategoryIndex && 
              sourceTaskIndex !== targetTaskIndex) {
            reorderTask(categoryIndex, phaseIndex, subcategoryIndex, sourceTaskIndex, targetTaskIndex);
          }
        } catch (error) {
          console.error('Error parsing drag data:', error);
        }
      });
    }
    
    // Reorder task in data structure
    function reorderTask(categoryIndex, phaseIndex, subcategoryIndex, fromIndex, toIndex) {
      if (dataManager.reorderTask(categoryIndex, phaseIndex, subcategoryIndex, fromIndex, toIndex)) {
        saveProgress();
        renderChecklist();
      }
    }

    // Legacy function - now uses subcategoryRenderer
    function createSubSectionElement(subSectionKey, subSection, categoryIndex, phaseIndex, subcategoryIndex) {
      return subcategoryRenderer.createSubcategoryElement(subSectionKey, subSection, categoryIndex, phaseIndex, subcategoryIndex);
    }
    
    // Create task row (new array format)
    function createTaskRow(task, categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex = null, isSubtask = false) {
      const isCompleted = task.completed === true;
      const hasLinks = task.links && task.links.length > 0;

      // Create swipe container
      const swipeContainer = document.createElement('div');
      swipeContainer.className = 'swipe-container';

      // Create swipe content (the actual row)
      const row = document.createElement('div');
      row.className = `swipe-content flex items-center justify-between p-4 transition-colors duration-150 draggable-task ${hasLinks ? 'hover:bg-slate-50 dark:hover:bg-slate-700/50 cursor-pointer' : ''}`;
      row.setAttribute('data-category-index', categoryIndex);
      row.setAttribute('data-phase-index', phaseIndex);
      row.setAttribute('data-subcategory-index', subcategoryIndex);
      row.setAttribute('data-task-index', taskIndex);
      row.setAttribute('data-task-name', task.name); // Store task name for reference
      row.draggable = true;
      if (subtaskIndex !== null) {
        row.setAttribute('data-subtask-index', subtaskIndex);
      }
      
      // Make entire row clickable (except checkbox, drag handle) to show links
      if (hasLinks) {
        row.onclick = (e) => {
          // Don't trigger if clicking checkbox, drag handle, label (for editing), or if swiped
          if (e.target.type === 'checkbox' || 
              e.target.classList.contains('drag-handle') || 
              e.target.closest('.drag-handle') ||
              e.target.contentEditable === 'true' || 
              row.classList.contains('swiped')) {
            return;
          }
          showTaskLinks(task.links, task.name, row);
        };
      }
      
      const leftDiv = document.createElement('div');
      leftDiv.className = 'flex items-center space-x-4 flex-1';
      
      // Drag handle for task (left-most item)
      const dragHandle = document.createElement('span');
      dragHandle.className = 'material-symbols-outlined drag-handle text-slate-400 hover:text-slate-600 cursor-move mr-2';
      dragHandle.textContent = 'drag_indicator';
      dragHandle.title = 'Drag to reorder';
      dragHandle.style.pointerEvents = 'auto'; // Ensure drag handle is interactive
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'h-5 w-5 rounded border-slate-300 text-primary focus:ring-primary dark:bg-slate-900 dark:border-slate-600';
      checkbox.checked = isCompleted;
      checkbox.onclick = (e) => {
        e.stopPropagation();
        toggleTask(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex);
        updateTaskRow(row, task);
      };

      const label = document.createElement('span');
      label.className = `text-slate-700 dark:text-slate-300 ${isCompleted ? 'strikethrough' : ''} ${hasLinks ? 'cursor-pointer' : 'cursor-text'}`;
      label.textContent = task.name;
      label.contentEditable = false;
      label.setAttribute('data-task-name', task.name); // Store task name for reference
      
      // Make label editable on double-click
      label.ondblclick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        if (!label.contentEditable || label.contentEditable === 'false') {
          label.contentEditable = true;
          label.focus();
          // Select all text for easy editing
          const range = document.createRange();
          range.selectNodeContents(label);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      };
      
      // Save edited text when user finishes editing
      label.onblur = () => {
        if (label.contentEditable === 'true' || label.contentEditable === true) {
          label.contentEditable = false;
          const newText = label.textContent.trim();
          const taskObj = getTaskObject(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex);
          const currentTaskName = taskObj ? taskObj.name : task.name;
          
          if (newText && newText !== currentTaskName && taskObj) {
            // Update the task name in the data structure
            taskObj.name = newText;
            saveProgress();
          } else if (!newText) {
            // Restore original text if empty
            label.textContent = currentTaskName;
          }
        }
      };
      
      // Prevent Enter key from creating new line, save instead
      label.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          label.blur();
        }
        // Allow Escape to cancel editing
        if (e.key === 'Escape') {
          const taskObj = getTaskObject(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex);
          const currentTaskName = taskObj ? taskObj.name : task.name;
          label.textContent = currentTaskName;
          label.contentEditable = false;
          label.blur();
        }
      };

      leftDiv.appendChild(dragHandle);
      leftDiv.appendChild(checkbox);
      leftDiv.appendChild(label);

      const rightIcon = document.createElement('span');
      rightIcon.className = 'material-symbols-outlined text-slate-400 dark:text-slate-500';
      rightIcon.textContent = hasLinks ? 'chevron_right' : '';
      rightIcon.style.pointerEvents = 'none'; // Icon is just visual, row handles click

      row.appendChild(leftDiv);
      if (hasLinks) {
        row.appendChild(rightIcon);
      }

      // Create delete button
      const deleteButton = document.createElement('div');
      deleteButton.className = 'swipe-delete';
      deleteButton.innerHTML = '<span class="material-symbols-outlined">delete</span>';
      deleteButton.onclick = (e) => {
        e.stopPropagation();
        deleteTask(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex, swipeContainer);
      };

      swipeContainer.appendChild(row);
      swipeContainer.appendChild(deleteButton);

      // Add swipe functionality
      addSwipeHandlers(row, swipeContainer);
      
      // Setup drag and drop for task
      setupTaskDragAndDrop(row, categoryIndex, phaseIndex, subcategoryIndex, taskIndex);

      return swipeContainer;
    }

    // Update task row appearance
    function updateTaskRow(row, task) {
      const checkbox = row.querySelector('input[type="checkbox"]');
      const label = row.querySelector(`span[data-task-name="${task.name}"]`);
      const isCompleted = task.completed === true;

      if (checkbox) checkbox.checked = isCompleted;
      if (label) {
        if (isCompleted) {
          label.classList.add('strikethrough');
        } else {
          label.classList.remove('strikethrough');
        }
      }
    }

    // Add swipe handlers for touch and mouse events
    function addSwipeHandlers(row, swipeContainer, swipeDistance = 80) {
      let startX = 0;
      let currentX = 0;
      let isDragging = false;
      let hasSwiped = false;

      // Touch events
      row.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        isDragging = true;
        hasSwiped = false;
      });

      row.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        currentX = e.touches[0].clientX;
        const diffX = startX - currentX;
        
        // Only allow swiping left (positive diffX)
        if (diffX > 0) {
          e.preventDefault();
          const translateX = Math.min(diffX, swipeDistance);
          row.style.transform = `translateX(-${translateX}px)`;
          hasSwiped = translateX > (swipeDistance / 2); // Threshold for revealing buttons
        }
      });

      row.addEventListener('touchend', () => {
        if (isDragging) {
          const editButton = swipeContainer.querySelector('.swipe-edit');
          const deleteButton = swipeContainer.querySelector('.swipe-delete');
          if (hasSwiped) {
            row.classList.add('swiped');
            row.style.transform = `translateX(-${swipeDistance}px)`;
            // Show buttons
            if (editButton) editButton.style.display = 'flex';
            if (deleteButton) deleteButton.style.display = 'flex';
          } else {
            row.classList.remove('swiped');
            row.style.transform = 'translateX(0)';
            // Hide buttons
            if (editButton) editButton.style.display = 'none';
            if (deleteButton) deleteButton.style.display = 'none';
          }
          isDragging = false;
        }
      });

      // Mouse events (for desktop)
      row.addEventListener('mousedown', (e) => {
        // Only allow swipe on right side of row or if already swiped
        const rect = row.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const rowWidth = rect.width;
        
        // Allow swipe if clicking on right 30% of row or if already swiped
        if (clickX > rowWidth * 0.7 || row.classList.contains('swiped')) {
          startX = e.clientX;
          isDragging = true;
          hasSwiped = row.classList.contains('swiped');
          row.style.transition = 'none';
        }
      });

      row.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        currentX = e.clientX;
        const diffX = startX - currentX;
        
        // Only allow swiping left (positive diffX)
        if (diffX > 0) {
          const translateX = Math.min(diffX, swipeDistance);
          row.style.transform = `translateX(-${translateX}px)`;
          hasSwiped = translateX > (swipeDistance / 2);
        }
      });

      row.addEventListener('mouseup', () => {
        if (isDragging) {
          const editButton = swipeContainer.querySelector('.swipe-edit');
          const deleteButton = swipeContainer.querySelector('.swipe-delete');
          row.style.transition = 'transform 0.3s ease-out';
          if (hasSwiped) {
            row.classList.add('swiped');
            row.style.transform = `translateX(-${swipeDistance}px)`;
            // Show buttons
            if (editButton) editButton.style.display = 'flex';
            if (deleteButton) deleteButton.style.display = 'flex';
          } else {
            row.classList.remove('swiped');
            row.style.transform = 'translateX(0)';
            // Hide buttons
            if (editButton) editButton.style.display = 'none';
            if (deleteButton) deleteButton.style.display = 'none';
          }
          isDragging = false;
        }
      });

      row.addEventListener('mouseleave', () => {
        if (isDragging) {
          const editButton = swipeContainer.querySelector('.swipe-edit');
          const deleteButton = swipeContainer.querySelector('.swipe-delete');
          row.style.transition = 'transform 0.3s ease-out';
          if (hasSwiped) {
            row.classList.add('swiped');
            row.style.transform = `translateX(-${swipeDistance}px)`;
            // Show buttons
            if (editButton) editButton.style.display = 'flex';
            if (deleteButton) deleteButton.style.display = 'flex';
          } else {
            row.classList.remove('swiped');
            row.style.transform = 'translateX(0)';
            // Hide buttons
            if (editButton) editButton.style.display = 'none';
            if (deleteButton) deleteButton.style.display = 'none';
          }
          isDragging = false;
        }
      });

    }

    // Delete task from checklist (new array format)
    function deleteTask(categoryIndex, phaseIndex, subcategoryIndex, taskIndex, subtaskIndex, swipeContainer) {
      const { items } = getSubcategoryData(categoryIndex, phaseIndex, subcategoryIndex);
      if (!items || !Array.isArray(items)) {
        console.error('Invalid task data structure');
        return;
      }

      // Filter to only tasks (not nested containers) for deletion
      const taskItems = items.filter(item => isTaskObject(item));
      if (taskIndex >= taskItems.length) return;
      
      // Find the actual index in the items array
      let actualTaskIndex = -1;
      let taskCount = 0;
      
      for (let i = 0; i < items.length; i++) {
        if (isTaskObject(items[i])) {
          if (taskCount === taskIndex) {
            actualTaskIndex = i;
            break;
          }
          taskCount++;
        }
      }
      
      if (actualTaskIndex === -1) return;
      
      const task = items[actualTaskIndex];
      
      if (subtaskIndex !== null) {
        // Delete a subtask - find the subtask in nested arrays
        for (const [key, value] of Object.entries(task)) {
          if (key === 'links' || key === 'tags') continue;
          if (Array.isArray(value)) {
            let currentSubtaskIndex = 0;
            for (let i = 0; i < value.length; i++) {
              if (isTaskObject(value[i])) {
                if (currentSubtaskIndex === subtaskIndex) {
                  value.splice(i, 1);
                  break;
                }
                currentSubtaskIndex++;
              }
            }
          }
        }
      } else {
        // Delete the main task
        items.splice(actualTaskIndex, 1);
      }

      // Save updated data
      saveProgress();
      
      // Remove the swipe container from DOM
      swipeContainer.remove();
      
      // Update progress
      updateOverallProgress();
      updateCategoryProgress(categoryIndex, phaseIndex);
      
      // Update phase and subcategory checkbox states
      const phaseCheckbox = document.querySelector(
        `[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"] input[type="checkbox"]`
      );
        if (phaseCheckbox) {
        updatePhaseCheckboxState(categoryIndex, phaseIndex, phaseCheckbox);
      }
      
      const subcategoryCheckbox = document.querySelector(
        `[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"][data-subcategory-index="${subcategoryIndex}"] input[type="checkbox"]`
      );
      if (subcategoryCheckbox) {
        updateSubcategoryCheckboxState(categoryIndex, phaseIndex, subcategoryIndex, subcategoryCheckbox);
      }
    }

    // Delete sub-section and all its tasks (new array format)
    function deleteSubSection(categoryIndex, phaseIndex, subcategoryIndex, subSectionDiv) {
      const { subcategories } = getPhaseData(categoryIndex, phaseIndex);
      if (!subcategories || subcategoryIndex >= subcategories.length) {
        console.error('Invalid sub-section data structure');
        return;
      }

      // Delete the subcategory from the data structure
      subcategories.splice(subcategoryIndex, 1);

      // Save updated data
      saveProgress();

      // Remove the sub-section div from DOM
      subSectionDiv.remove();

      // Update progress
      updateOverallProgress();
      updateCategoryProgress(categoryIndex, phaseIndex);

      // Update phase checkbox state
      const phaseCheckbox = document.querySelector(
        `[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"] input[type="checkbox"]`
      );
        if (phaseCheckbox) {
        updatePhaseCheckboxState(categoryIndex, phaseIndex, phaseCheckbox);
      }
    }

    // Delete phase and all its sub-sections and tasks (new array format)
    function deletePhase(categoryIndex, phaseIndex, categoryDiv) {
      const { phases } = getCategoryData(categoryIndex);
      if (!phases || phaseIndex >= phases.length) {
        console.error('Invalid phase data structure');
        return;
      }

      // Delete the phase from the data structure
      phases.splice(phaseIndex, 1);

      // Save updated data
      saveProgress();

      // Remove the category div from DOM
      categoryDiv.remove();

      // Update overall progress
      updateOverallProgress();
    }

    // Track currently selected task row
    let selectedTaskRow = null;
    // Track current task info for adding resources
    let currentTaskInfo = null;

    // Get tag color classes based on tag type
    function getTagColorClasses(tag) {
      const tagLower = tag.toLowerCase().trim();
      const tagNormalized = tagLower.replace(/[\/\s]+/g, ' '); // Normalize slashes and spaces
      
      const colorMap = {
        'video': 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300',
        'blog': 'bg-purple-100 text-purple-800 dark:bg-purple-900/30 dark:text-purple-300',
        'social media': 'bg-pink-100 text-pink-800 dark:bg-pink-900/30 dark:text-pink-300',
        'e-commerce': 'bg-orange-100 text-orange-800 dark:bg-orange-900/30 dark:text-orange-300',
        'news': 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300',
        'government official': 'bg-indigo-100 text-indigo-800 dark:bg-indigo-900/30 dark:text-indigo-300',
        'government/official': 'bg-indigo-100 text-indigo-800 dark:bg-indigo-900/30 dark:text-indigo-300',
        'visa': 'bg-cyan-100 text-cyan-800 dark:bg-cyan-900/30 dark:text-cyan-300',
        'housing': 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300',
        'finance': 'bg-emerald-100 text-emerald-800 dark:bg-emerald-900/30 dark:text-emerald-300',
        'legal': 'bg-amber-100 text-amber-800 dark:bg-amber-900/30 dark:text-amber-300',
        'health': 'bg-rose-100 text-rose-800 dark:bg-rose-900/30 dark:text-rose-300',
        'work': 'bg-teal-100 text-teal-800 dark:bg-teal-900/30 dark:text-teal-300',
        'transport': 'bg-sky-100 text-sky-800 dark:bg-sky-900/30 dark:text-sky-300',
        'logistics': 'bg-violet-100 text-violet-800 dark:bg-violet-900/30 dark:text-violet-300',
        'digital': 'bg-fuchsia-100 text-fuchsia-800 dark:bg-fuchsia-900/30 dark:text-fuchsia-300',
        'family': 'bg-lime-100 text-lime-800 dark:bg-lime-900/30 dark:text-lime-300',
        'culture': 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300',
        'planning': 'bg-slate-100 text-slate-800 dark:bg-slate-700/30 dark:text-slate-300'
      };
      
      // Try exact match first (with original case)
      if (colorMap[tag]) {
        return colorMap[tag];
      }
      
      // Try normalized match
      if (colorMap[tagNormalized]) {
        return colorMap[tagNormalized];
      }
      
      // Try lowercase match
      if (colorMap[tagLower]) {
        return colorMap[tagLower];
      }
      
      // Try partial match for tags like "Government/Official"
      for (const [key, value] of Object.entries(colorMap)) {
        const keyNormalized = key.toLowerCase().replace(/[\/\s]+/g, ' ');
        if (tagNormalized.includes(keyNormalized) || keyNormalized.includes(tagNormalized)) {
          return value;
        }
      }
      
      // Default color
      return 'bg-primary/10 text-primary dark:bg-primary/20 dark:text-primary';
    }

    // Show task links in the right column
    function showTaskLinks(links, taskName, taskRow = null) {
      const linksList = document.getElementById('links-list');
      const linksContainer = document.getElementById('links-container');
      const drawerOverlay = document.getElementById('drawer-overlay');
      
      // Extract task info from taskRow if available (new array format)
      if (taskRow) {
        const categoryIndex = parseInt(taskRow.getAttribute('data-category-index')) || 0;
        const phaseIndex = parseInt(taskRow.getAttribute('data-phase-index')) || 0;
        const subcategoryIndex = parseInt(taskRow.getAttribute('data-subcategory-index')) || 0;
        const taskIndex = parseInt(taskRow.getAttribute('data-task-index')) || 0;
        const taskName = taskRow.getAttribute('data-task-name');
        currentTaskInfo = { categoryIndex, phaseIndex, subcategoryIndex, taskIndex, taskName };
      } else {
        currentTaskInfo = null;
      }
      
      // Remove highlight from previously selected row
      if (selectedTaskRow) {
        selectedTaskRow.classList.remove('bg-primary/10', 'border-primary/20', 'border-l-4');
      }
      
      // Highlight current row and update links container background
      if (taskRow) {
        selectedTaskRow = taskRow;
        taskRow.classList.add('bg-primary/10', 'border-primary/20', 'border-l-4');
        // Match the links container background to the highlight color
        linksContainer.classList.remove('bg-white', 'dark:bg-slate-900');
        linksContainer.classList.add('bg-primary/10', 'dark:bg-primary/10');
      } else {
        // Reset background if no task is selected
        linksContainer.classList.remove('bg-primary/10', 'dark:bg-primary/10');
        linksContainer.classList.add('bg-white', 'dark:bg-slate-900');
        selectedTaskRow = null;
      }
      
      // Clear existing links
      linksList.innerHTML = '';

      if (!links || links.length === 0) {
        linksList.innerHTML = '<p class="text-sm text-slate-500 dark:text-slate-400 text-center py-8">No resources available for this task</p>';
        // Add "+ Resource" button if we have task info
        if (currentTaskInfo) {
          const addResourceButton = document.createElement('button');
          addResourceButton.className = 'add-button w-full mt-4';
          addResourceButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>+ Resource</span>';
          addResourceButton.onclick = () => {
            if (currentTaskInfo) {
              // Use new structure if available
              if (currentTaskInfo.categoryIndex !== undefined) {
                showAddResourceDialog(currentTaskInfo.categoryIndex, currentTaskInfo.phaseIndex, currentTaskInfo.subcategoryIndex, currentTaskInfo.taskIndex);
              } else {
              showAddResourceDialog(currentTaskInfo.mainKey, currentTaskInfo.phaseKey, currentTaskInfo.subSectionKey, currentTaskInfo.taskIndex);
              }
            }
          };
          linksList.appendChild(addResourceButton);
        }
        // Open drawer on mobile even if no links
        openDrawer();
        return;
      }

      // Create cards for each link with swipe-to-delete
      links.forEach((link, linkIndex) => {
        // Handle both new format (object with link_url) and old format (string)
        const linkUrl = typeof link === 'string' ? link : (link.link_url || '');
        const linkTitle = typeof link === 'string' ? link : (link.title || 'Untitled Resource');
        const linkImage = typeof link === 'string' ? '' : (link.image_url || '');
        const linkTags = typeof link === 'string' ? [] : (link.tags || []);
        
        // Create swipe container
        const swipeContainer = document.createElement('div');
        swipeContainer.className = 'swipe-container';
        
        const card = document.createElement('div');
        card.className = 'swipe-content swipe-content-resource bg-slate-50 dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700 overflow-hidden hover:shadow-md transition-shadow duration-200 cursor-pointer relative';
        card.onclick = (e) => {
          // If clicking edit icon, edit button, or delete button, let them handle it
          if (e.target.closest('.resource-edit-icon') || e.target.closest('.swipe-edit') || e.target.closest('.swipe-delete')) {
            return;
          }
          // If swiped, reset it
          if (card.classList.contains('swiped')) {
            e.preventDefault();
            e.stopPropagation();
            const editButton = swipeContainer.querySelector('.swipe-edit');
            const deleteButton = swipeContainer.querySelector('.swipe-delete');
            card.classList.remove('swiped');
            card.style.transform = 'translateX(0)';
            // Hide buttons
            if (editButton) editButton.style.display = 'none';
            if (deleteButton) deleteButton.style.display = 'none';
            return;
          }
          // Otherwise, open the link
          if (linkUrl) {
            window.open(linkUrl, '_blank');
          }
        };
        
        // Add edit icon in upper-right corner
        const editIcon = document.createElement('div');
        editIcon.className = 'resource-edit-icon';
        editIcon.innerHTML = '<span class="material-symbols-outlined">more_vert</span>';
        editIcon.onclick = (e) => {
          e.stopPropagation();
          e.preventDefault();
          // Toggle swipe reveal
          const editButton = swipeContainer.querySelector('.swipe-edit');
          const deleteButton = swipeContainer.querySelector('.swipe-delete');
          if (card.classList.contains('swiped')) {
            // Hide buttons
            card.classList.remove('swiped');
            card.style.transform = 'translateX(0)';
            if (editButton) editButton.style.display = 'none';
            if (deleteButton) deleteButton.style.display = 'none';
          } else {
            // Show buttons
            card.classList.add('swiped');
            card.style.transform = 'translateX(-160px)';
            if (editButton) editButton.style.display = 'flex';
            if (deleteButton) deleteButton.style.display = 'flex';
          }
        };
        
        // Append icon to card (card has position: relative)
        card.appendChild(editIcon);

        // Image section (if image_url exists)
        if (linkImage && linkImage.trim() !== '') {
          const imageDiv = document.createElement('div');
          imageDiv.className = 'w-full bg-white overflow-hidden flex items-center justify-center p-3';
          imageDiv.style.minHeight = '120px';
          imageDiv.style.maxHeight = '200px';
          const img = document.createElement('img');
          img.src = linkImage;
          img.alt = linkTitle;
          img.className = 'w-full h-auto max-h-full object-contain';
          img.style.maxWidth = '100%';
          img.onerror = () => {
            // Hide image on error
            imageDiv.style.display = 'none';
          };
          imageDiv.appendChild(img);
          card.appendChild(imageDiv);
        }

        // Content section
        const contentDiv = document.createElement('div');
        contentDiv.className = 'p-4';

        // Title
        const titleDiv = document.createElement('div');
        titleDiv.className = 'font-semibold text-slate-900 dark:text-white mb-2 line-clamp-2';
        titleDiv.textContent = linkTitle;
        contentDiv.appendChild(titleDiv);

        // Tags
        if (linkTags && Array.isArray(linkTags) && linkTags.length > 0) {
          const tagsDiv = document.createElement('div');
          tagsDiv.className = 'flex flex-wrap gap-1.5 mt-2';
          linkTags.forEach(tag => {
            const tagSpan = document.createElement('span');
            tagSpan.className = `inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${getTagColorClasses(tag)}`;
            tagSpan.textContent = tag;
            tagsDiv.appendChild(tagSpan);
          });
          contentDiv.appendChild(tagsDiv);
        }

        card.appendChild(contentDiv);
        
        // Create edit button
        const editButton = document.createElement('div');
        editButton.className = 'swipe-edit';
        editButton.innerHTML = '<span class="material-symbols-outlined">edit</span>';
        editButton.onclick = (e) => {
          e.stopPropagation();
          const resource = typeof link === 'string' 
            ? { title: linkTitle, link_url: linkUrl, image_url: linkImage, tags: linkTags }
            : link;
          // Use new structure if available, otherwise fall back to old structure
          if (currentTaskInfo && currentTaskInfo.categoryIndex !== undefined) {
            showEditResourceDialog(currentTaskInfo.categoryIndex, currentTaskInfo.phaseIndex, currentTaskInfo.subcategoryIndex, currentTaskInfo.taskIndex, linkIndex, resource, swipeContainer);
          } else if (currentTaskInfo) {
          showEditResourceDialog(currentTaskInfo.mainKey, currentTaskInfo.phaseKey, currentTaskInfo.subSectionKey, currentTaskInfo.taskIndex, linkIndex, resource, swipeContainer);
          }
        };
        
        // Create delete button
        const deleteButton = document.createElement('div');
        deleteButton.className = 'swipe-delete';
        deleteButton.innerHTML = '<span class="material-symbols-outlined">delete</span>';
        deleteButton.onclick = (e) => {
          e.stopPropagation();
          // Use new structure if available, otherwise fall back to old structure
          if (currentTaskInfo && currentTaskInfo.categoryIndex !== undefined) {
            deleteResource(currentTaskInfo.categoryIndex, currentTaskInfo.phaseIndex, currentTaskInfo.subcategoryIndex, currentTaskInfo.taskIndex, linkIndex, swipeContainer);
          } else if (currentTaskInfo) {
          deleteResource(currentTaskInfo.mainKey, currentTaskInfo.phaseKey, currentTaskInfo.subSectionKey, currentTaskInfo.taskIndex, linkIndex, swipeContainer);
          }
        };
        
        swipeContainer.appendChild(card);
        swipeContainer.appendChild(editButton);
        swipeContainer.appendChild(deleteButton);
        
        // Add swipe functionality with 160px distance for resources (to show both edit and delete)
        addSwipeHandlers(card, swipeContainer, 160);
        
        linksList.appendChild(swipeContainer);
      });
      
      // Add "+ Resource" button at the bottom
      if (currentTaskInfo) {
        const addResourceButton = document.createElement('button');
        addResourceButton.className = 'add-button w-full mt-4';
        addResourceButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Resource</span>';
        addResourceButton.onclick = () => {
          if (currentTaskInfo) {
            // Use new structure if available, otherwise fall back to old structure
            if (currentTaskInfo.categoryIndex !== undefined) {
              showAddResourceDialog(currentTaskInfo.categoryIndex, currentTaskInfo.phaseIndex, currentTaskInfo.subcategoryIndex, currentTaskInfo.taskIndex);
            } else {
            showAddResourceDialog(currentTaskInfo.mainKey, currentTaskInfo.phaseKey, currentTaskInfo.subSectionKey, currentTaskInfo.taskIndex);
            }
          }
        };
        linksList.appendChild(addResourceButton);
      }
      
      // Open drawer on mobile
      openDrawer();
    }
    
    // Delete resource from task (supports both old and new structure)
    function deleteResource(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex, linkIndex, swipeContainer) {
      // Determine if using new structure (numeric indices) or old structure (string keys)
      const isNewStructure = typeof categoryIndexOrMainKey === 'number';
      let task;
      
      if (isNewStructure) {
        task = getTaskObject(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex);
      } else {
        // Old structure
        if (checklistData[categoryIndexOrMainKey] && checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey] && 
            checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey][subcategoryIndexOrSubSectionKey] &&
            checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey][subcategoryIndexOrSubSectionKey].tasks) {
          task = checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey][subcategoryIndexOrSubSectionKey].tasks[taskIndex];
        }
      }
      
      if (task && task.links && task.links[linkIndex]) {
        task.links.splice(linkIndex, 1);
        saveProgress();
        swipeContainer.remove();
        
        // Refresh the links display
        if (currentTaskInfo && currentTaskInfo.taskName) {
          const taskRow = document.querySelector(`[data-task-name="${currentTaskInfo.taskName}"]`)?.closest('.swipe-content');
        if (taskRow) {
          showTaskLinks(task.links, task.name, taskRow);
          }
        }
      }
    }

    // Drawer functions for mobile
    function openDrawer() {
      const linksContainer = document.getElementById('links-container');
      const drawerOverlay = document.getElementById('drawer-overlay');
      
      // Only show drawer on mobile (below lg breakpoint)
      if (window.innerWidth < 1024) {
        linksContainer.classList.remove('translate-x-full');
        linksContainer.classList.add('translate-x-0');
        if (drawerOverlay) {
          drawerOverlay.classList.remove('hidden');
        }
        // Prevent body scroll when drawer is open
        document.body.style.overflow = 'hidden';
      }
    }

    function closeDrawer() {
      const linksContainer = document.getElementById('links-container');
      const drawerOverlay = document.getElementById('drawer-overlay');
      
      linksContainer.classList.remove('translate-x-0');
      linksContainer.classList.add('translate-x-full');
      if (drawerOverlay) {
        drawerOverlay.classList.add('hidden');
      }
      // Restore body scroll
      document.body.style.overflow = '';
    }

    // Toggle category expand/collapse
    function toggleCategory(categoryDiv) {
      const content = categoryDiv.querySelector('.category-content');
      const caret = categoryDiv.querySelector('.category-caret');
      const isExpanded = content.style.display !== 'none';

      if (isExpanded) {
        content.style.display = 'none';
        caret.textContent = 'chevron_right';
        caret.style.transform = 'rotate(0deg)';
      } else {
        content.style.display = 'block';
        caret.textContent = 'expand_more';
      }
    }
    
    // Toggle subcategory expand/collapse
    function toggleSubcategory(subcategoryDiv) {
      const content = subcategoryDiv.querySelector('.subcategory-content');
      const caret = subcategoryDiv.querySelector('.subcategory-caret');
      if (!content || !caret) return;
      
      const isExpanded = content.style.display !== 'none';

      if (isExpanded) {
        content.style.display = 'none';
        caret.textContent = 'chevron_right';
      } else {
        content.style.display = 'block';
        caret.textContent = 'expand_more';
      }
    }

    // Calculate category progress
    function calculateCategoryProgress(categoryIndex, phaseIndex) {
      const { subcategories } = getPhaseData(categoryIndex, phaseIndex);
      if (!subcategories) return 0;
      
      let total = 0;
      let completed = 0;

      function countTasksInArray(arr) {
        if (!Array.isArray(arr)) return;
        
        arr.forEach((item) => {
          if (isTaskObject(item)) {
            total++;
            if (item.completed === true) completed++;
            
            // Check for nested tasks
            Object.values(item).forEach(value => {
              if (Array.isArray(value)) {
                value.forEach((subItem) => {
                  if (isTaskObject(subItem)) {
                total++;
                    if (subItem.completed === true) completed++;
                  }
              });
            }
          });
          } else if (typeof item === 'object' && item !== null) {
            // Nested container - recursively process
            Object.values(item).forEach(value => {
              if (Array.isArray(value)) {
                countTasksInArray(value);
              }
            });
          }
        });
      }

      subcategories.forEach((subcategoryObj, subcategoryIndex) => {
        const subcategoryName = Object.keys(subcategoryObj)[0];
        const subcategory = subcategoryObj[subcategoryName];
        if (Array.isArray(subcategory)) {
          countTasksInArray(subcategory, subcategoryIndex);
        }
      });

      return total > 0 ? Math.round((completed / total) * 100) : 0;
    }

    // Update category progress (new array format)
    function updateCategoryProgress(categoryIndex = null, phaseIndex = null) {
      const checklistData = stateManager.get('checklistData');
      if (!checklistData || !Array.isArray(checklistData)) return;
      
      const categoryIdx = categoryIndex !== null ? categoryIndex : 0;
      const { phases } = getCategoryData(categoryIdx);
      if (!phases) return;

      if (phaseIndex !== null) {
        // Update specific phase
        const categoryDiv = document.querySelector(`[data-category-index="${categoryIdx}"][data-phase-index="${phaseIndex}"]`);
        if (categoryDiv) {
          const progress = calculateCategoryProgress(categoryIdx, phaseIndex);
          const progressText = categoryDiv.querySelector('.category-progress-text');
          const progressBar = categoryDiv.querySelector('.category-progress-bar');
          if (progressText) progressText.textContent = `${progress}% Complete`;
          if (progressBar) progressBar.style.width = `${progress}%`;
        }
      } else {
        // Update all phases
        phases.forEach((phaseObj, idx) => {
          updateCategoryProgress(categoryIdx, idx);
        });
      }
    }

    // Update overall progress (new array format)
    function updateOverallProgress() {
      const checklistData = stateManager.get('checklistData');
      if (!checklistData || !Array.isArray(checklistData)) return;
      
      let total = 0;
      let completed = 0;

      checklistData.forEach((categoryObj, categoryIndex) => {
        const categoryName = Object.keys(categoryObj)[0];
        const phases = categoryObj[categoryName];
        if (!Array.isArray(phases)) return;
        
        phases.forEach((phaseObj, phaseIndex) => {
          const phaseName = Object.keys(phaseObj)[0];
          const subcategories = phaseObj[phaseName];
          if (!Array.isArray(subcategories)) return;
          
          subcategories.forEach((subcategoryObj) => {
            const subcategoryName = Object.keys(subcategoryObj)[0];
            const subcategory = subcategoryObj[subcategoryName];
            if (Array.isArray(subcategory)) {
              subcategory.forEach((item) => {
                if (isTaskObject(item)) {
              total++;
                  if (item.completed === true) completed++;
                  
                  // Check for nested tasks
                  Object.values(item).forEach(value => {
                    if (Array.isArray(value)) {
                      value.forEach((subItem) => {
                        if (isTaskObject(subItem)) {
                  total++;
                          if (subItem.completed === true) completed++;
                        }
                });
              }
            });
                } else if (typeof item === 'object' && item !== null) {
                  // Nested container - recursively process
                  Object.values(item).forEach(value => {
                    if (Array.isArray(value)) {
                      value.forEach((nestedItem) => {
                        if (isTaskObject(nestedItem)) {
                          total++;
                          if (nestedItem.completed === true) completed++;
                        }
                      });
                    }
                  });
                }
              });
            }
          });
        });
      });

      const percent = total > 0 ? Math.round((completed / total) * 100) : 0;
      document.getElementById('overall-progress-percent').textContent = `${percent}%`;
      document.getElementById('overall-progress-text').textContent = 
        `You've completed ${completed} out of ${total} tasks. ${completed < total ? 'Keep going!' : 'Congratulations!'}`;
      document.getElementById('overall-progress-bar').style.width = `${percent}%`;
    }

    // Legacy handleSignup - now opens auth modal
    function handleSignup() {
      openAuthModal();
    }

    // Add new phase (new array format)
    function addNewPhase(categoryIndex) {
      const { phases } = getCategoryData(categoryIndex);
      if (!phases) return;
      
      const newPhaseName = `New Phase ${phases.length + 1}`;
      phases.push({
        [newPhaseName]: []
      });
      
      saveProgress();
      renderChecklist();
    }

    // Add new category/sub-section (new array format)
    function addNewCategory(categoryIndex, phaseIndex, contentDiv) {
      const { subcategories } = getPhaseData(categoryIndex, phaseIndex);
      if (!subcategories) return;
      
      const newCategoryName = `New Category ${subcategories.length + 1}`;
      subcategories.push({
        [newCategoryName]: []
      });
      
      saveProgress();
      
      // Re-render just this phase's content
      const categoryDiv = contentDiv.closest(`[data-category-index="${categoryIndex}"][data-phase-index="${phaseIndex}"]`);
      const oldContent = categoryDiv.querySelector('.category-content');
      const newContent = document.createElement('div');
      newContent.className = 'category-content space-y-6';
      newContent.style.display = oldContent.style.display;
      
      // Re-render all subcategories
      subcategories.forEach((subcategoryObj, subcategoryIndex) => {
        const subcategoryName = Object.keys(subcategoryObj)[0];
        const subcategory = subcategoryObj[subcategoryName];
        if (Array.isArray(subcategory)) {
          const subSectionElement = createSubSectionElement(subcategoryName, subcategory, categoryIndex, phaseIndex, subcategoryIndex);
        newContent.appendChild(subSectionElement);
      }
      });
      
      // Add "+ Category" button
      const addCategoryButton = document.createElement('button');
      addCategoryButton.className = 'add-button w-full';
      addCategoryButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Category</span>';
      addCategoryButton.onclick = () => addNewCategory(categoryIndex, phaseIndex, newContent);
      newContent.appendChild(addCategoryButton);
      
      oldContent.replaceWith(newContent);
      updateCategoryProgress(categoryIndex, phaseIndex);
    }

    // Show dialog to add new task (new array format)
    function showAddTaskDialog(categoryIndex, phaseIndex, subcategoryIndex, tasksContainer, subSectionDiv) {
      const overlay = document.createElement('div');
      overlay.className = 'dialog-overlay';
      overlay.onclick = (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      };
      
      const dialog = document.createElement('div');
      dialog.className = 'dialog-content';
      dialog.onclick = (e) => e.stopPropagation();
      
      dialog.innerHTML = `
        <div class="dialog-header">
          <h3 class="dialog-title">Add New Task</h3>
          <button class="dialog-close" id="dialog-close-btn">
            <span class="material-symbols-outlined">close</span>
          </button>
        </div>
        <form id="add-task-form">
          <div class="dialog-form-group">
            <label class="dialog-label" for="task-name">Task Name *</label>
            <input type="text" id="task-name" class="dialog-input" required placeholder="Enter task name">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="task-description">Description (optional)</label>
            <textarea id="task-description" class="dialog-textarea" placeholder="Enter task description"></textarea>
          </div>
          <div class="dialog-actions">
            <button type="button" class="btn-secondary" id="dialog-cancel-btn">Cancel</button>
            <button type="submit" class="btn-primary">Add Task</button>
          </div>
        </form>
      `;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // Wire up close and cancel buttons
      const closeBtn = dialog.querySelector('#dialog-close-btn');
      const cancelBtn = dialog.querySelector('#dialog-cancel-btn');
      const closeDialog = () => overlay.remove();
      if (closeBtn) closeBtn.onclick = closeDialog;
      if (cancelBtn) cancelBtn.onclick = closeDialog;
      
      const form = dialog.querySelector('#add-task-form');
      form.onsubmit = (e) => {
        e.preventDefault();
        const taskName = dialog.querySelector('#task-name').value.trim();
        const taskDescription = dialog.querySelector('#task-description').value.trim();
        
        if (taskName) {
          try {
            addNewTask(categoryIndex, phaseIndex, subcategoryIndex, taskName, taskDescription, tasksContainer, subSectionDiv);
            overlay.remove();
          } catch (error) {
            console.error('Error adding task:', error);
            alert('Error adding task: ' + error.message);
          }
        } else {
          alert('Please enter a task name');
        }
      };
      
      dialog.querySelector('#task-name').focus();
    }

    // Add new task (new array format)
    function addNewTask(categoryIndex, phaseIndex, subcategoryIndex, taskName, taskDescription, tasksContainer, subSectionDiv) {
      const { items } = getSubcategoryData(categoryIndex, phaseIndex, subcategoryIndex);
      if (!items || !Array.isArray(items)) {
        throw new Error('Invalid subcategory data structure');
      }
      
      const newTask = {
        name: taskName,
        description: taskDescription || '',
        links: [],
        completed: false
      };
      
      // Add task to the items array
      items.push(newTask);
      const taskIndex = items.filter(item => isTaskObject(item)).length - 1;
      
      // Remove the "+ Task" button temporarily
      const addButton = tasksContainer.querySelector('.add-button');
      if (addButton) {
        addButton.remove();
      }
      
      // Add the new task row
      const taskRow = createTaskRow(newTask, categoryIndex, phaseIndex, subcategoryIndex, taskIndex);
      tasksContainer.appendChild(taskRow);
      
      // Re-add the "+ Task" button
      const newAddButton = document.createElement('button');
      newAddButton.className = 'add-button w-full';
      newAddButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Task</span>';
      newAddButton.onclick = () => showAddTaskDialog(categoryIndex, phaseIndex, subcategoryIndex, tasksContainer, subSectionDiv);
      tasksContainer.appendChild(newAddButton);
      
      saveProgress();
      updateOverallProgress();
      updateCategoryProgress(categoryIndex, phaseIndex);
      
      // Update subcategory checkbox state
      const subcategoryCheckbox = subSectionDiv.querySelector('input[type="checkbox"]');
      if (subcategoryCheckbox) {
        updateSubcategoryCheckboxState(categoryIndex, phaseIndex, subcategoryIndex, subcategoryCheckbox);
      }
    }

    // Show dialog to add new resource (supports both old and new structure)
    function showAddResourceDialog(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex) {
      // Determine if using new structure (numeric indices) or old structure (string keys)
      const isNewStructure = typeof categoryIndexOrMainKey === 'number';
      const categoryIndex = isNewStructure ? categoryIndexOrMainKey : 0;
      const phaseIndex = isNewStructure ? phaseIndexOrPhaseKey : 0;
      const subcategoryIndex = isNewStructure ? subcategoryIndexOrSubSectionKey : 0;
      const mainKey = isNewStructure ? null : categoryIndexOrMainKey;
      const phaseKey = isNewStructure ? null : phaseIndexOrPhaseKey;
      const subSectionKey = isNewStructure ? null : subcategoryIndexOrSubSectionKey;
      const overlay = document.createElement('div');
      overlay.className = 'dialog-overlay';
      overlay.onclick = (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      };
      
      const dialog = document.createElement('div');
      dialog.className = 'dialog-content';
      dialog.onclick = (e) => e.stopPropagation();
      
      dialog.innerHTML = `
        <div class="dialog-header">
          <h3 class="dialog-title">Add New Resource</h3>
          <button class="dialog-close" id="dialog-close-btn">
            <span class="material-symbols-outlined">close</span>
          </button>
        </div>
        <form id="add-resource-form">
          <div class="dialog-form-group">
            <label class="dialog-label" for="resource-title">Title *</label>
            <input type="text" id="resource-title" class="dialog-input" required placeholder="Enter resource title">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="resource-url">URL *</label>
            <input type="url" id="resource-url" class="dialog-input" required placeholder="https://example.com">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="resource-image">Image URL (optional)</label>
            <input type="url" id="resource-image" class="dialog-input" placeholder="https://example.com/image.jpg">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="resource-tags">Tags (comma-separated, optional)</label>
            <input type="text" id="resource-tags" class="dialog-input" placeholder="blog, video, official">
          </div>
          <div class="dialog-actions">
            <button type="button" class="btn-secondary" id="dialog-cancel-btn">Cancel</button>
            <button type="submit" class="btn-primary">Add Resource</button>
          </div>
        </form>
      `;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // Wire up close and cancel buttons
      const closeBtn = dialog.querySelector('#dialog-close-btn');
      const cancelBtn = dialog.querySelector('#dialog-cancel-btn');
      const closeDialog = () => overlay.remove();
      if (closeBtn) closeBtn.onclick = closeDialog;
      if (cancelBtn) cancelBtn.onclick = closeDialog;
      
      const form = dialog.querySelector('#add-resource-form');
      form.onsubmit = (e) => {
        e.preventDefault();
        const title = dialog.querySelector('#resource-title').value.trim();
        const url = dialog.querySelector('#resource-url').value.trim();
        const image = dialog.querySelector('#resource-image').value.trim();
        const tagsStr = dialog.querySelector('#resource-tags').value.trim();
        const tags = tagsStr ? tagsStr.split(',').map(t => t.trim()).filter(t => t) : [];
        
        if (title && url) {
          try {
            addNewResource(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex, title, url, image, tags);
            overlay.remove();
            // Refresh the links display - use currentTaskInfo if available
            if (currentTaskInfo) {
              const task = isNewStructure 
                ? getTaskObject(categoryIndex, phaseIndex, subcategoryIndex, taskIndex)
                : (checklistData[mainKey] && checklistData[mainKey][phaseKey] && checklistData[mainKey][phaseKey][subSectionKey] && checklistData[mainKey][phaseKey][subSectionKey].tasks ? checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex] : null);
              if (task) {
                const taskRow = document.querySelector(`[data-task-name="${task.name}"]`)?.closest('.swipe-content');
            if (taskRow) {
              showTaskLinks(task.links, task.name, taskRow);
                }
              }
            }
          } catch (error) {
            console.error('Error adding resource:', error);
            alert('Error adding resource: ' + error.message);
          }
        } else {
          alert('Please enter both title and URL');
        }
      };
      
      dialog.querySelector('#resource-title').focus();
    }

    // Add new resource to task (supports both old and new structure)
    function addNewResource(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex, title, url, image, tags) {
      // Determine if using new structure (numeric indices) or old structure (string keys)
      const isNewStructure = typeof categoryIndexOrMainKey === 'number';
      let task;
      
      if (isNewStructure) {
        task = getTaskObject(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex);
      } else {
        // Old structure
        if (checklistData[categoryIndexOrMainKey] && checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey] && 
            checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey][subcategoryIndexOrSubSectionKey] &&
            checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey][subcategoryIndexOrSubSectionKey].tasks) {
          task = checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey][subcategoryIndexOrSubSectionKey].tasks[taskIndex];
        }
      }
      
      if (!task) {
        throw new Error('Task not found');
      }
      
      if (!task.links) {
        task.links = [];
      }
      
      const newResource = {
        title: title,
        link_url: url,
        image_url: image || '',
        tags: tags || []
      };
      
      task.links.push(newResource);
      saveProgress();
    }

    // Show dialog to edit existing resource (supports both old and new structure)
    function showEditResourceDialog(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex, linkIndex, resource, swipeContainer) {
      // Determine if using new structure (numeric indices) or old structure (string keys)
      const isNewStructure = typeof categoryIndexOrMainKey === 'number';
      const categoryIndex = isNewStructure ? categoryIndexOrMainKey : 0;
      const phaseIndex = isNewStructure ? phaseIndexOrPhaseKey : 0;
      const subcategoryIndex = isNewStructure ? subcategoryIndexOrSubSectionKey : 0;
      const mainKey = isNewStructure ? null : categoryIndexOrMainKey;
      const phaseKey = isNewStructure ? null : phaseIndexOrPhaseKey;
      const subSectionKey = isNewStructure ? null : subcategoryIndexOrSubSectionKey;
      const overlay = document.createElement('div');
      overlay.className = 'dialog-overlay';
      overlay.onclick = (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      };
      
      const dialog = document.createElement('div');
      dialog.className = 'dialog-content';
      dialog.onclick = (e) => e.stopPropagation();
      
      // Get current values
      const currentTitle = typeof resource === 'string' ? resource : (resource.title || '');
      const currentUrl = typeof resource === 'string' ? resource : (resource.link_url || '');
      const currentImage = typeof resource === 'string' ? '' : (resource.image_url || '');
      const currentTags = typeof resource === 'string' ? [] : (resource.tags || []);
      const currentTagsStr = Array.isArray(currentTags) ? currentTags.join(', ') : '';
      
      dialog.innerHTML = `
        <div class="dialog-header">
          <h3 class="dialog-title">Edit Resource</h3>
          <button class="dialog-close" id="dialog-close-btn">
            <span class="material-symbols-outlined">close</span>
          </button>
        </div>
        <form id="edit-resource-form">
          <div class="dialog-form-group">
            <label class="dialog-label" for="edit-resource-title">Title *</label>
            <input type="text" id="edit-resource-title" class="dialog-input" required placeholder="Enter resource title" value="${currentTitle.replace(/"/g, '&quot;')}">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="edit-resource-url">URL *</label>
            <input type="url" id="edit-resource-url" class="dialog-input" required placeholder="https://example.com" value="${currentUrl.replace(/"/g, '&quot;')}">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="edit-resource-image">Image URL (optional)</label>
            <input type="url" id="edit-resource-image" class="dialog-input" placeholder="https://example.com/image.jpg" value="${currentImage.replace(/"/g, '&quot;')}">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="edit-resource-tags">Tags (comma-separated, optional)</label>
            <input type="text" id="edit-resource-tags" class="dialog-input" placeholder="blog, video, official" value="${currentTagsStr.replace(/"/g, '&quot;')}">
          </div>
          <div class="dialog-actions">
            <button type="button" class="btn-secondary" id="dialog-cancel-btn">Cancel</button>
            <button type="submit" class="btn-primary">Save Changes</button>
          </div>
        </form>
      `;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // Wire up close and cancel buttons
      const closeBtn = dialog.querySelector('#dialog-close-btn');
      const cancelBtn = dialog.querySelector('#dialog-cancel-btn');
      const closeDialog = () => overlay.remove();
      if (closeBtn) closeBtn.onclick = closeDialog;
      if (cancelBtn) cancelBtn.onclick = closeDialog;
      
      const form = dialog.querySelector('#edit-resource-form');
      form.onsubmit = (e) => {
        e.preventDefault();
        const title = dialog.querySelector('#edit-resource-title').value.trim();
        const url = dialog.querySelector('#edit-resource-url').value.trim();
        const image = dialog.querySelector('#edit-resource-image').value.trim();
        const tagsStr = dialog.querySelector('#edit-resource-tags').value.trim();
        const tags = tagsStr ? tagsStr.split(',').map(t => t.trim()).filter(t => t) : [];
        
        if (title && url) {
          try {
            updateResource(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex, linkIndex, title, url, image, tags);
            overlay.remove();
            // Refresh the links display - use currentTaskInfo if available
            if (currentTaskInfo) {
              const task = isNewStructure 
                ? getTaskObject(categoryIndex, phaseIndex, subcategoryIndex, taskIndex)
                : (checklistData[mainKey] && checklistData[mainKey][phaseKey] && checklistData[mainKey][phaseKey][subSectionKey] && checklistData[mainKey][phaseKey][subSectionKey].tasks ? checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex] : null);
              if (task) {
                const taskRow = document.querySelector(`[data-task-name="${task.name}"]`)?.closest('.swipe-content');
            if (taskRow) {
              showTaskLinks(task.links, task.name, taskRow);
                }
              }
            }
          } catch (error) {
            console.error('Error updating resource:', error);
            alert('Error updating resource: ' + error.message);
          }
        } else {
          alert('Please enter both title and URL');
        }
      };
      
      dialog.querySelector('#edit-resource-title').focus();
    }

    // Update existing resource (supports both old and new structure)
    function updateResource(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex, linkIndex, title, url, image, tags) {
      // Determine if using new structure (numeric indices) or old structure (string keys)
      const isNewStructure = typeof categoryIndexOrMainKey === 'number';
      let task;
      
      if (isNewStructure) {
        task = getTaskObject(categoryIndexOrMainKey, phaseIndexOrPhaseKey, subcategoryIndexOrSubSectionKey, taskIndex);
      } else {
        // Old structure
        if (checklistData[categoryIndexOrMainKey] && checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey] && 
            checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey][subcategoryIndexOrSubSectionKey] &&
            checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey][subcategoryIndexOrSubSectionKey].tasks) {
          task = checklistData[categoryIndexOrMainKey][phaseIndexOrPhaseKey][subcategoryIndexOrSubSectionKey].tasks[taskIndex];
        }
      }
      
      if (!task) {
        throw new Error('Task not found');
      }
      
      if (task.links && task.links[linkIndex]) {
        // Handle both old format (string) and new format (object)
        if (typeof task.links[linkIndex] === 'string') {
          // Convert old format to new format
          task.links[linkIndex] = {
            title: title,
            link_url: url,
            image_url: image || '',
            tags: tags || []
          };
        } else {
          // Update existing object
          task.links[linkIndex].title = title;
          task.links[linkIndex].link_url = url;
          task.links[linkIndex].image_url = image || '';
          task.links[linkIndex].tags = tags || [];
        }
        saveProgress();
      } else {
        throw new Error('Resource not found');
      }
    }

    // Wire up Overall Progress swipe and refresh
    function wireUpOverallProgressSwipe() {
      const progressContent = document.getElementById('overall-progress-content');
      const progressContainer = progressContent?.closest('.swipe-container');
      const refreshButton = document.getElementById('overall-progress-refresh');
      
      if (!progressContent || !progressContainer || !refreshButton) {
        console.warn('Overall Progress elements not found');
        return;
      }
      
      // Wire up refresh button click
      refreshButton.onclick = (e) => {
        e.stopPropagation();
        resetChecklist();
      };
      
      // Add swipe handlers
      addSwipeHandlers(progressContent, progressContainer);
    }

    // Wire up signup button (now auth button)
    function wireUpSignupButton() {
      // The auth button is already set up with onclick="openAuthModal()" in the HTML
      // and is updated by updateAuthButton() based on auth state
      // This function is kept for compatibility but doesn't need to do anything
      const authButton = document.getElementById('auth-button');
      if (authButton) {
        // Button is already properly configured in HTML
        // updateAuthButton() will handle dynamic updates based on auth state
      } else {
        console.warn('Auth button not found!');
      }
    }

    // Wire up drawer close functionality
    function wireUpDrawer() {
      const closeBtn = document.getElementById('close-drawer-btn');
      const overlay = document.getElementById('drawer-overlay');
      
      if (closeBtn) {
        closeBtn.addEventListener('click', closeDrawer);
      }
      
      if (overlay) {
        overlay.addEventListener('click', closeDrawer);
      }
      
      // Close drawer on window resize if switching to desktop
      window.addEventListener('resize', () => {
        if (window.innerWidth >= 1024) {
          closeDrawer();
        }
      });
    }
    
    // Global handler to close swiped rows when clicking outside (only add once)
    if (!swipeCloseHandlerAdded) {
      document.addEventListener('click', (e) => {
        // Find all swiped rows
        const swipedRows = document.querySelectorAll('.swipe-content.swiped, .swipe-content-resource.swiped');
        swipedRows.forEach(swipedRow => {
          const swipeContainer = swipedRow.closest('.swipe-container');
          if (swipeContainer && !swipeContainer.contains(e.target)) {
            const editButton = swipeContainer.querySelector('.swipe-edit');
            const deleteButton = swipeContainer.querySelector('.swipe-delete');
            swipedRow.classList.remove('swiped');
            swipedRow.style.transform = 'translateX(0)';
            // Hide buttons
            if (editButton) editButton.style.display = 'none';
            if (deleteButton) deleteButton.style.display = 'none';
          }
        });
      }, true);
      swipeCloseHandlerAdded = true;
    }
    
    // Utility function to clear all user data (for testing)
    // Call this from browser console: clearAllUserData()
    window.clearAllUserData = function() {
      // Clear all cookies
      document.cookie.split(";").forEach(function(c) { 
        const cookieName = c.replace(/^ +/, "").split("=")[0];
        document.cookie = cookieName + "=;expires=" + new Date(0).toUTCString() + ";path=/";
      });
      
      // Clear localStorage items
      localStorage.removeItem('move2japan_anonymous_user_id');
      localStorage.removeItem('move2japan_auth_token');
      localStorage.removeItem('move2japan_user_info');
      localStorage.removeItem('move2japan_email_gate_suppressed');
      
      // Clear in-memory state
      authToken = null;
      currentUser = null;
      stateManager.setState({ checklistData: null, authToken: null, currentUser: null });
      
      console.log('âœ… All user data cleared! Reloading page...');
      
      // Reload the page to reset everything
      setTimeout(() => {
        window.location.reload();
      }, 500);
    };
    
    // Initialize on page load
    init();
    
    // Wire up signup button when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        wireUpSignupButton();
        wireUpDrawer();
        initEmailModal();
      });
    } else {
      // DOM already loaded
      wireUpSignupButton();
      wireUpDrawer();
      initEmailModal();
    }
  </script>

  <!-- UserBack Feedback Widget -->
  <script>
    window.Userback = window.Userback || {};

    Userback.access_token = "A-w4OQPAJGddZyhz0o2RCfyuaQk";

    (function(d) {
      var s = d.createElement('script');s.async = true;s.src = 'https://static.userback.io/widget/v1.js';(d.head || d.body).appendChild(s);
    })(document);
  </script>

  <!-- MailerLite Scripts -->
  <script src="https://groot.mailerlite.com/js/w/webforms.min.js?v176e10baa5e7ed80d35ae235be3d5024" type="text/javascript"></script>
  <script>
    fetch("https://assets.mailerlite.com/jsonp/1923093/forms/171195070484055534/takel")
  </script>
</body>
</html>
