<!DOCTYPE html>
<html class="light" lang="en">
<head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  
  <!-- SEO Meta Tags -->
  <title>Moving to Japan Checklist - Complete Guide for US Citizens | Move2Japan</title>
  <meta name="description" content="A comprehensive, interactive checklist for moving to Japan from the US. Track your progress through visa applications, housing, banking, and all essential tasks for relocating to Japan.">
  <meta name="keywords" content="moving to Japan, Japan relocation checklist, US to Japan move, Japan visa guide, relocate to Japan, Japan immigration checklist, Japan moving guide, expat Japan">
  <meta name="author" content="Move2Japan">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://move2japan.com/">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://move2japan.com/">
  <meta property="og:title" content="Moving to Japan Checklist - Complete Guide for US Citizens">
  <meta property="og:description" content="A comprehensive, interactive checklist for moving to Japan from the US. Track your progress through visa applications, housing, banking, and all essential tasks.">
  <meta property="og:image" content="https://images.unsplash.com/photo-1478436127897-769e1b3f0f36?q=80&w=1200&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:alt" content="Beautiful landscape view of Japan with mountains and traditional architecture">
  <meta property="og:site_name" content="Move2Japan">
  <meta property="og:locale" content="en_US">
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://move2japan.com/">
  <meta name="twitter:title" content="Moving to Japan Checklist - Complete Guide for US Citizens">
  <meta name="twitter:description" content="A comprehensive, interactive checklist for moving to Japan from the US. Track your progress through visa applications, housing, banking, and all essential tasks.">
  <meta name="twitter:image" content="https://images.unsplash.com/photo-1478436127897-769e1b3f0f36?q=80&w=1200&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D">
  <meta name="twitter:image:alt" content="Beautiful landscape view of Japan with mountains and traditional architecture">
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  
  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Moving to Japan Checklist",
    "description": "A comprehensive, interactive checklist for moving to Japan from the US. Track your progress through visa applications, housing, banking, and all essential tasks for relocating to Japan.",
    "url": "https://move2japan.com/",
    "applicationCategory": "UtilityApplication",
    "operatingSystem": "Web",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "featureList": [
      "Interactive checklist with progress tracking",
      "Visa and immigration guidance",
      "Housing and banking resources",
      "Comprehensive relocation tasks",
      "Resource links for each task"
    ]
  }
  </script>
  
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  <link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;600;700&display=swap" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet"/>
  <script src="https://t.contentsquare.net/uxa/5947da0fdab10.js"></script>
  <!-- Cloudflare Web Analytics -->
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "3f2ed07ac03a48759de724f05c9b8d9a"}'></script>
  <script>
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            primary: "#0EA5E9", // sky-500
            "background-light": "#F8FAFC", // slate-50
            "background-dark": "#020617", // slate-950
          },
          fontFamily: {
            display: ["Sora", "sans-serif"],
          },
          borderRadius: {
            DEFAULT: "0.5rem", // 8px
          },
        },
      },
    };
  </script>
  <style>
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }
    .strikethrough {
      text-decoration: line-through;
      color: #94a3b8;
    }
    .dark .strikethrough {
      color: #64748b;
    }
    /* Indeterminate checkbox styling */
    input[type="checkbox"]:indeterminate {
      background-color: #0EA5E9;
      border-color: #0EA5E9;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='none' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3E%3C/svg%3E");
    }
    /* Line clamp utility */
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    /* Links container max-height for desktop */
    @media (min-width: 1024px) {
      #links-container {
        max-height: calc(100vh - 8rem);
      }
    }
    /* Swipe to delete container */
    .swipe-container {
      position: relative;
      overflow: hidden;
      width: 100%;
    }
    .swipe-content {
      position: relative;
      width: 100%;
      transition: transform 0.3s ease-out;
      background-color: inherit;
    }
    .swipe-content.swiped {
      transform: translateX(-80px);
    }
    .swipe-delete {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 80px;
      background-color: #ef4444;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
    }
    .swipe-content.swiped ~ .swipe-delete {
      display: flex;
    }
    .swipe-delete:hover {
      background-color: #dc2626;
    }
    .swipe-delete .material-symbols-outlined {
      color: white;
      font-size: 24px;
    }
    /* Swipe refresh button (for Overall Progress) */
    .swipe-refresh {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 80px;
      background-color: #0EA5E9;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
    }
    .swipe-refresh:hover {
      background-color: #0284c7;
    }
    .swipe-refresh .material-symbols-outlined {
      color: white;
      font-size: 24px;
    }
    .swipe-content.swiped ~ .swipe-refresh {
      display: flex;
    }
    /* Dialog/Modal styles */
    .dialog-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-center;
      padding: 1rem;
    }
    .dialog-content {
      background-color: white;
      border-radius: 0.5rem;
      padding: 1.5rem;
      max-width: 500px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    }
    .dark .dialog-content {
      background-color: #0f172a;
    }
    .dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    .dialog-title {
      font-size: 1.25rem;
      font-weight: 700;
      color: #0f172a;
    }
    .dark .dialog-title {
      color: white;
    }
    .dialog-close {
      background: none;
      border: none;
      cursor: pointer;
      color: #64748b;
      padding: 0.25rem;
    }
    .dialog-close:hover {
      color: #0f172a;
    }
    .dark .dialog-close:hover {
      color: white;
    }
    .dialog-form-group {
      margin-bottom: 1rem;
    }
    .dialog-label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      color: #0f172a;
      margin-bottom: 0.5rem;
    }
    .dark .dialog-label {
      color: #e2e8f0;
    }
    .dialog-input {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #cbd5e1;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      background-color: white;
      color: #0f172a;
    }
    .dark .dialog-input {
      background-color: #1e293b;
      border-color: #475569;
      color: white;
    }
    .dialog-textarea {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #cbd5e1;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      min-height: 80px;
      resize: vertical;
      background-color: white;
      color: #0f172a;
    }
    .dark .dialog-textarea {
      background-color: #1e293b;
      border-color: #475569;
      color: white;
    }
    .dialog-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }
    .btn-primary {
      background-color: #0EA5E9;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }
    .btn-primary:hover {
      background-color: #0284c7;
    }
    .btn-secondary {
      background-color: #e2e8f0;
      color: #0f172a;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }
    .dark .btn-secondary {
      background-color: #475569;
      color: white;
    }
    .btn-secondary:hover {
      background-color: #cbd5e1;
    }
    .dark .btn-secondary:hover {
      background-color: #64748b;
    }
    /* Add button styles */
    .add-button {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      margin-top: 0.5rem;
      background-color: #f1f5f9;
      border: 2px dashed #cbd5e1;
      border-radius: 0.5rem;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }
    .dark .add-button {
      background-color: #1e293b;
      border-color: #475569;
      color: #94a3b8;
    }
    .add-button:hover {
      background-color: #e2e8f0;
      border-color: #0EA5E9;
      color: #0EA5E9;
    }
    .dark .add-button:hover {
      background-color: #334155;
      border-color: #0EA5E9;
      color: #0EA5E9;
    }
    /* Editable title styles */
    .editable-title {
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      transition: background-color 0.2s;
    }
    .editable-title:hover {
      background-color: #f1f5f9;
    }
    .dark .editable-title:hover {
      background-color: #1e293b;
    }
    .editable-title[contenteditable="true"] {
      outline: 2px solid #0EA5E9;
      outline-offset: 2px;
      background-color: white;
    }
    .dark .editable-title[contenteditable="true"] {
      background-color: #1e293b;
    }
  </style>
</head>
<body class="bg-background-light dark:bg-background-dark font-display">
  <div class="min-h-screen">
    <!-- Header -->
    <header class="relative bg-cover bg-center h-[50vh] min-h-[300px] md:h-[400px]" style="background-image: url('https://images.unsplash.com/photo-1478436127897-769e1b3f0f36?q=80&w=1170&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D');" role="img" aria-label="Beautiful landscape view of Japan with mountains and traditional architecture">
      <div class="absolute inset-0 bg-black/50"></div>
      <div class="relative z-10 mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 h-full">
        <div class="flex justify-between items-start pt-6">
          <div class="text-white font-bold text-xl">ðŸ‡¯ðŸ‡µ</div>
          <a class="rounded-lg bg-primary px-5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-sky-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-primary" href="javascript:void(0)" onclick="handleSignup()">Signup</a>
        </div>
        <div class="flex flex-col items-center justify-center h-full text-center text-white pb-16">
          <h1 class="text-4xl font-bold tracking-tight sm:text-5xl md:text-6xl">Moving to Japan Checklist</h1>
          <p class="mt-4 max-w-2xl text-lg sm:text-xl text-slate-200">A comprehensive to do guide for moving to Japan from the US</p>
        </div>
      </div>
    </header>

    <!-- Main Content -->
    <main class="pt-8 pb-20">
      <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
        <!-- Overall Progress -->
        <div class="mb-6 swipe-container">
          <div id="overall-progress-content" class="swipe-content bg-white dark:bg-slate-900 rounded-lg shadow-xl p-6 sm:p-8">
          <div class="flex justify-between items-center mb-2">
            <h2 class="text-lg font-bold text-slate-900 dark:text-white">Overall Progress</h2>
            <span id="overall-progress-percent" class="text-lg font-bold text-primary">0%</span>
          </div>
          <p id="overall-progress-text" class="text-sm text-slate-600 dark:text-slate-400 mb-4">Loading...</p>
          <div class="w-full bg-slate-200 dark:bg-slate-700 rounded-full h-3">
            <div id="overall-progress-bar" class="bg-primary h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
          </div>
          <div id="overall-progress-refresh" class="swipe-refresh">
            <span class="material-symbols-outlined">refresh</span>
          </div>
        </div>

        <!-- Two Column Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <!-- Checklist Container (Left Column - 2/3 width) -->
          <div class="lg:col-span-2">
            <div id="checklist-container" class="bg-background-light dark:bg-slate-900 rounded-lg shadow-xl p-6 sm:p-8 space-y-8">
              <div class="text-center text-slate-600 dark:text-slate-400">Loading checklist...</div>
            </div>
          </div>

          <!-- Links Column (Right Column - 1/3 width, Drawer on mobile) -->
          <div class="lg:col-span-1">
            <div id="links-container" class="fixed lg:sticky top-0 right-0 h-full lg:h-auto w-full max-w-sm lg:max-w-none bg-white dark:bg-slate-900 rounded-lg lg:rounded-lg shadow-xl lg:shadow-xl p-6 flex flex-col transform translate-x-full lg:translate-x-0 transition-transform duration-300 ease-in-out z-50" style="max-height: 100vh;">
              <!-- Drawer header with close button (mobile only) -->
              <div class="flex justify-between items-center mb-4 lg:hidden">
                <h3 class="text-lg font-bold text-slate-900 dark:text-white">Recommend Resources</h3>
                <button id="close-drawer-btn" class="text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200">
                  <span class="material-symbols-outlined">close</span>
                </button>
              </div>
              <!-- Desktop header -->
              <h3 class="text-lg font-bold text-slate-900 dark:text-white mb-4 flex-shrink-0 hidden lg:block">Resources</h3>
              <div id="links-list" class="space-y-4 overflow-y-auto flex-1">
                <p class="text-sm text-slate-500 dark:text-slate-400 text-center py-8">
                  Click on a checklist item to view related resources
                </p>
              </div>
            </div>
            <!-- Drawer overlay (mobile only) -->
            <div id="drawer-overlay" class="fixed inset-0 bg-black/50 z-40 lg:hidden hidden"></div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // Cookie management
    const COOKIE_NAME = 'japan_checklist_data';
    const COOKIE_EXPIRY_DAYS = 365;

    function setCookie(name, value, days) {
      const expires = new Date();
      expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
      // Use SameSite=Lax for better compatibility (works for same-site and most cross-site scenarios)
      document.cookie = `${name}=${encodeURIComponent(JSON.stringify(value))};expires=${expires.toUTCString()};path=/;SameSite=Lax`;
    }

    function getCookie(name) {
      const nameEQ = name + "=";
      const ca = document.cookie.split(';');
      for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) === 0) {
          try {
            return JSON.parse(decodeURIComponent(c.substring(nameEQ.length, c.length)));
          } catch (e) {
            return null;
          }
        }
      }
      return null;
    }

    // Checklist state management
    let checklistData = null;
    let completedTasks = new Set();
    let swipeCloseHandlerAdded = false;
    
    // Default URL for checklist JSON
    const DEFAULT_CHECKLIST_URL = 'https://gist.githubusercontent.com/jalakoo/44ba89b8f60fc97400c9750112e5ba7c/raw/move2japan_from_us.json';

    // Load initial checklist from JSON URL
    async function loadInitialChecklist() {
      // Get URL from query parameter or use default
      const urlParams = new URLSearchParams(window.location.search);
      const checklistUrl = urlParams.get('checklist_url') || DEFAULT_CHECKLIST_URL;
      
      try {
        const response = await fetch(checklistUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error loading checklist from URL:', error);
        return null;
      }
    }

    // Reset checklist to original state
    async function resetChecklist() {
      // Clear the cookie by setting it to expire in the past
      const expires = new Date();
      expires.setTime(expires.getTime() - 1);
      document.cookie = `${COOKIE_NAME}=;expires=${expires.toUTCString()};path=/;SameSite=Lax`;
      
      // Reset completed tasks
      completedTasks = new Set();
      
      // Reload checklist from DEFAULT_CHECKLIST_URL
      checklistData = await loadInitialChecklist();
      
      if (checklistData) {
        // Save fresh state to cookie
        setCookie(COOKIE_NAME, {
          checklistData: checklistData,
          completedTasks: []
        }, COOKIE_EXPIRY_DAYS);
        
        // Re-render the checklist
        renderChecklist();
        updateOverallProgress();
        
        console.log('Checklist reset to original state');
      } else {
        console.error('Failed to reload checklist');
        alert('Failed to reload checklist. Please refresh the page.');
      }
    }

    // Initialize app
    async function init() {
      // Check if user has visited before and has saved progress
      const savedData = getCookie(COOKIE_NAME);
      
      // Restore saved progress first (before loading new data)
      if (savedData && savedData.completedTasks && Array.isArray(savedData.completedTasks)) {
        completedTasks = new Set(savedData.completedTasks);
        console.log('Restored', completedTasks.size, 'completed tasks from cookie');
      } else {
        completedTasks = new Set();
      }
      
      // Always load the latest checklist from URL (in case it was updated)
      checklistData = await loadInitialChecklist();
      
      if (checklistData) {
        // Save current state to cookie (with latest checklist data and preserved selections)
        // This ensures the cookie is updated with the latest checklist structure
        setCookie(COOKIE_NAME, {
          checklistData: checklistData,
          completedTasks: Array.from(completedTasks)
        }, COOKIE_EXPIRY_DAYS);
        
        renderChecklist();
        updateOverallProgress();
      } else {
        // If loading fails, try to use saved data as fallback
        if (savedData && savedData.checklistData) {
          checklistData = savedData.checklistData;
          // Keep the already restored completedTasks
          renderChecklist();
          updateOverallProgress();
        } else {
          document.getElementById('checklist-container').innerHTML = 
            '<div class="text-center text-red-600">Failed to load checklist. Please refresh the page.</div>';
        }
      }
      
      // Wire up Overall Progress swipe and refresh button
      wireUpOverallProgressSwipe();
    }

    // Count all tasks recursively
    function countAllTasks(data) {
      let count = 0;
      for (const phaseKey in data) {
        const phase = data[phaseKey];
        for (const categoryKey in phase) {
          const category = phase[categoryKey];
          for (const subSectionKey in category) {
            const subSection = category[subSectionKey];
            if (subSection.tasks) {
              subSection.tasks.forEach(task => {
                count++;
                if (task.subtasks) {
                  count += task.subtasks.length;
                }
              });
            }
          }
        }
      }
      return count;
    }

    // Get task ID
    function getTaskId(phaseKey, categoryKey, subSectionKey, taskIndex, subtaskIndex = null) {
      if (subtaskIndex !== null) {
        return `${phaseKey}::${categoryKey}::${subSectionKey}::${taskIndex}::${subtaskIndex}`;
      }
      return `${phaseKey}::${categoryKey}::${subSectionKey}::${taskIndex}`;
    }

    // Check if task is completed
    function isTaskCompleted(taskId) {
      return completedTasks.has(taskId);
    }

    // Toggle task completion
    function toggleTask(taskId) {
      if (completedTasks.has(taskId)) {
        completedTasks.delete(taskId);
      } else {
        completedTasks.add(taskId);
      }
      saveProgress();
      updateOverallProgress();
      updateCategoryProgress();
      
      // Update phase checkbox state if task belongs to a phase
      const parts = taskId.split('::');
      if (parts.length >= 2) {
        const phaseKey = parts[1];
        const mainKey = parts[0];
        const categoryDiv = document.querySelector(`[data-category-id="${phaseKey}"]`);
        if (categoryDiv) {
          const phaseCheckbox = categoryDiv.querySelector('input[type="checkbox"]');
          if (phaseCheckbox) {
            updatePhaseCheckboxState(phaseKey, mainKey, phaseCheckbox);
          }
        }
      }
    }

    // Toggle all tasks in a phase
    function togglePhaseTasks(phaseKey, mainKey, checked) {
      const phase = checklistData[mainKey][phaseKey];
      const taskIds = [];

      // Collect all task IDs in this phase
      for (const subSectionKey in phase) {
        const subSection = phase[subSectionKey];
        if (subSection.tasks) {
          subSection.tasks.forEach((task, taskIndex) => {
            const taskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex);
            taskIds.push(taskId);

            // Also collect subtasks
            if (task.subtasks) {
              task.subtasks.forEach((subtask, subtaskIndex) => {
                const subtaskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex);
                taskIds.push(subtaskId);
              });
            }
          });
        }
      }

      // Toggle all tasks
      if (checked) {
        taskIds.forEach(taskId => completedTasks.add(taskId));
      } else {
        taskIds.forEach(taskId => completedTasks.delete(taskId));
      }

      // Update UI for all affected task rows
      taskIds.forEach(taskId => {
        const parts = taskId.split('::');
        if (parts.length >= 4) {
          const row = document.querySelector(`span[data-task-id="${taskId}"]`)?.closest('.flex.items-center');
          if (row) {
            const checkbox = row.querySelector('input[type="checkbox"]');
            const label = row.querySelector(`span[data-task-id="${taskId}"]`);
            if (checkbox) {
              checkbox.checked = checked;
              if (label) {
                if (checked) {
                  label.classList.add('strikethrough');
                } else {
                  label.classList.remove('strikethrough');
                }
              }
            }
          }
        }
      });

      saveProgress();
      updateOverallProgress();
      updateCategoryProgress(phaseKey);
    }

    // Update phase checkbox state based on task completion
    function updatePhaseCheckboxState(phaseKey, mainKey, phaseCheckbox) {
      const phase = checklistData[mainKey][phaseKey];
      let totalTasks = 0;
      let completedCount = 0;

      // Count all tasks in this phase
      for (const subSectionKey in phase) {
        const subSection = phase[subSectionKey];
        if (subSection.tasks) {
          subSection.tasks.forEach((task, taskIndex) => {
            const taskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex);
            totalTasks++;
            if (isTaskCompleted(taskId)) {
              completedCount++;
            }

            // Also count subtasks
            if (task.subtasks) {
              task.subtasks.forEach((subtask, subtaskIndex) => {
                const subtaskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex);
                totalTasks++;
                if (isTaskCompleted(subtaskId)) {
                  completedCount++;
                }
              });
            }
          });
        }
      }

      // Set checkbox state: checked if all tasks are completed, indeterminate if some are completed
      if (totalTasks === 0) {
        phaseCheckbox.checked = false;
        phaseCheckbox.indeterminate = false;
      } else if (completedCount === totalTasks) {
        phaseCheckbox.checked = true;
        phaseCheckbox.indeterminate = false;
      } else if (completedCount > 0) {
        phaseCheckbox.checked = false;
        phaseCheckbox.indeterminate = true;
      } else {
        phaseCheckbox.checked = false;
        phaseCheckbox.indeterminate = false;
      }
    }

    // Save progress to cookie
    function saveProgress() {
      if (!checklistData) {
        console.warn('Cannot save progress: checklistData is not loaded');
        return;
      }
      const tasksArray = Array.from(completedTasks);
      setCookie(COOKIE_NAME, {
        checklistData: checklistData,
        completedTasks: tasksArray
      }, COOKIE_EXPIRY_DAYS);
      console.log('Saved', tasksArray.length, 'completed tasks to cookie');
    }

    // Render checklist
    function renderChecklist() {
      const container = document.getElementById('checklist-container');
      container.innerHTML = '';

      const mainKey = Object.keys(checklistData)[0];
      const phases = checklistData[mainKey];
      let isFirstPhase = true;

      for (const phaseKey in phases) {
        const phase = phases[phaseKey];
        const categoryElement = createCategoryElement(phaseKey, phase, mainKey, isFirstPhase);
        container.appendChild(categoryElement);
        isFirstPhase = false;
      }
      
      // Add "+ Phase" button at the bottom
      const addPhaseButton = document.createElement('button');
      addPhaseButton.className = 'add-button w-full';
      addPhaseButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Phase</span>';
      addPhaseButton.onclick = () => addNewPhase(mainKey);
      container.appendChild(addPhaseButton);
    }

    // Create category element (Phase)
    function createCategoryElement(phaseKey, phase, mainKey, isFirstPhase = true) {
      const categoryDiv = document.createElement('div');
      categoryDiv.className = 'space-y-4';
      categoryDiv.dataset.categoryId = phaseKey;

      // Create swipe container for phase header
      const phaseHeaderSwipeContainer = document.createElement('div');
      phaseHeaderSwipeContainer.className = 'swipe-container';

      // Category header
      const headerDiv = document.createElement('div');
      headerDiv.className = 'swipe-content flex justify-between items-center cursor-pointer';
      headerDiv.setAttribute('data-phase-key', phaseKey);
      headerDiv.setAttribute('data-main-key', mainKey);
      
      // Left side with checkbox and title
      const leftHeaderDiv = document.createElement('div');
      leftHeaderDiv.className = 'flex items-center space-x-3 flex-1';
      leftHeaderDiv.onclick = (e) => {
        // Don't toggle category if clicking on checkbox
        if (e.target.type !== 'checkbox' && e.target !== leftHeaderDiv.querySelector('input[type="checkbox"]')) {
          toggleCategory(categoryDiv);
        }
      };

      // Phase checkbox
      const phaseCheckbox = document.createElement('input');
      phaseCheckbox.type = 'checkbox';
      phaseCheckbox.className = 'h-5 w-5 rounded border-slate-300 text-primary focus:ring-primary dark:bg-slate-900 dark:border-slate-600';
      phaseCheckbox.onclick = (e) => {
        e.stopPropagation();
        togglePhaseTasks(phaseKey, mainKey, phaseCheckbox.checked);
      };

      const titleDiv = document.createElement('div');
      const titleH3 = document.createElement('h3');
      titleH3.className = 'text-xl font-bold text-slate-900 dark:text-white editable-title';
      titleH3.textContent = phaseKey;
      titleH3.contentEditable = false;
      titleH3.setAttribute('data-phase-key', phaseKey);
      titleH3.setAttribute('data-main-key', mainKey);
      
      // Make title editable on click
      titleH3.onclick = (e) => {
        e.stopPropagation();
        if (!titleH3.contentEditable || titleH3.contentEditable === 'false') {
          titleH3.contentEditable = true;
          titleH3.focus();
          const range = document.createRange();
          range.selectNodeContents(titleH3);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      };
      
      // Save edited title
      titleH3.onblur = () => {
        if (titleH3.contentEditable === 'true' || titleH3.contentEditable === true) {
          titleH3.contentEditable = false;
          const newTitle = titleH3.textContent.trim();
          if (newTitle && newTitle !== phaseKey) {
            // Rename phase in data structure
            const mainKey = titleH3.getAttribute('data-main-key');
            const oldPhaseKey = titleH3.getAttribute('data-phase-key');
            const phase = checklistData[mainKey][oldPhaseKey];
            delete checklistData[mainKey][oldPhaseKey];
            checklistData[mainKey][newTitle] = phase;
            
            // Update data attributes
            titleH3.setAttribute('data-phase-key', newTitle);
            categoryDiv.dataset.categoryId = newTitle;
            headerDiv.setAttribute('data-phase-key', newTitle);
            
            // Update all task IDs that reference this phase
            const newCompletedTasks = new Set();
            completedTasks.forEach(taskId => {
              const parts = taskId.split('::');
              if (parts.length >= 2 && parts[1] === oldPhaseKey) {
                parts[1] = newTitle;
                newCompletedTasks.add(parts.join('::'));
              } else {
                newCompletedTasks.add(taskId);
              }
            });
            completedTasks = newCompletedTasks;
            
            saveProgress();
            updateOverallProgress();
            updateCategoryProgress(newTitle);
          } else if (!newTitle) {
            titleH3.textContent = phaseKey;
          }
        }
      };
      
      // Prevent Enter key from creating new line, save instead
      titleH3.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          titleH3.blur();
        }
        if (e.key === 'Escape') {
          titleH3.textContent = phaseKey;
          titleH3.contentEditable = false;
          titleH3.blur();
        }
      };

      titleDiv.appendChild(titleH3);
      leftHeaderDiv.appendChild(phaseCheckbox);
      leftHeaderDiv.appendChild(titleDiv);

      const progressDiv = document.createElement('div');
      progressDiv.className = 'flex items-center space-x-2 text-sm text-slate-500 dark:text-slate-400';
      progressDiv.innerHTML = `
        <span class="category-progress-text">0% Complete</span>
        <span class="material-symbols-outlined text-base category-caret">${isFirstPhase ? 'expand_more' : 'chevron_right'}</span>
      `;
      progressDiv.onclick = (e) => {
        e.stopPropagation();
        toggleCategory(categoryDiv);
      };

      headerDiv.appendChild(leftHeaderDiv);
      headerDiv.appendChild(progressDiv);

      // Create delete button for phase
      const phaseDeleteButton = document.createElement('div');
      phaseDeleteButton.className = 'swipe-delete';
      phaseDeleteButton.innerHTML = '<span class="material-symbols-outlined">delete</span>';
      phaseDeleteButton.onclick = (e) => {
        e.stopPropagation();
        deletePhase(mainKey, phaseKey, categoryDiv);
      };

      phaseHeaderSwipeContainer.appendChild(headerDiv);
      phaseHeaderSwipeContainer.appendChild(phaseDeleteButton);

      // Add swipe functionality to phase header
      addSwipeHandlers(headerDiv, phaseHeaderSwipeContainer);

      // Progress bar
      const progressBarDiv = document.createElement('div');
      progressBarDiv.className = 'w-full bg-slate-200 dark:bg-slate-700 rounded-full h-2';
      progressBarDiv.innerHTML = '<div class="category-progress-bar bg-primary h-2 rounded-full transition-all duration-300" style="width: 0%"></div>';

      // Content container (collapsible)
      const contentDiv = document.createElement('div');
      contentDiv.className = 'category-content space-y-6';
      contentDiv.style.display = isFirstPhase ? 'block' : 'none'; // First phase expanded, others collapsed

      // Render sub-sections
      for (const subSectionKey in phase) {
        const subSection = phase[subSectionKey];
        const subSectionElement = createSubSectionElement(subSectionKey, subSection, mainKey, phaseKey);
        contentDiv.appendChild(subSectionElement);
      }

      // Add "+ Category" button as last item in phase
      const addCategoryButton = document.createElement('button');
      addCategoryButton.className = 'add-button w-full';
      addCategoryButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Category</span>';
      addCategoryButton.onclick = () => addNewCategory(mainKey, phaseKey, contentDiv);
      contentDiv.appendChild(addCategoryButton);

      categoryDiv.appendChild(phaseHeaderSwipeContainer);
      categoryDiv.appendChild(progressBarDiv);
      categoryDiv.appendChild(contentDiv);

      // Update category progress and checkbox state after rendering
      setTimeout(() => {
        updateCategoryProgress(phaseKey);
        updatePhaseCheckboxState(phaseKey, mainKey, phaseCheckbox);
      }, 0);

      return categoryDiv;
    }

    // Create sub-section element
    function createSubSectionElement(subSectionKey, subSection, mainKey, phaseKey) {
      const subSectionDiv = document.createElement('div');
      subSectionDiv.className = 'space-y-4';

      // Create swipe container for sub-section header
      const subSectionSwipeContainer = document.createElement('div');
      subSectionSwipeContainer.className = 'swipe-container';

      const subSectionTitle = document.createElement('h4');
      subSectionTitle.className = 'swipe-content text-lg font-semibold text-slate-800 dark:text-slate-200 py-2 cursor-pointer editable-title';
      subSectionTitle.textContent = subSectionKey;
      subSectionTitle.contentEditable = false;
      subSectionTitle.setAttribute('data-subsection-key', subSectionKey);
      subSectionTitle.setAttribute('data-phase-key', phaseKey);
      subSectionTitle.setAttribute('data-main-key', mainKey);
      
      // Make title editable on click
      subSectionTitle.onclick = (e) => {
        e.stopPropagation();
        if (!subSectionTitle.classList.contains('swiped') && (!subSectionTitle.contentEditable || subSectionTitle.contentEditable === 'false')) {
          subSectionTitle.contentEditable = true;
          subSectionTitle.focus();
          const range = document.createRange();
          range.selectNodeContents(subSectionTitle);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      };
      
      // Save edited title
      subSectionTitle.onblur = () => {
        if (subSectionTitle.contentEditable === 'true' || subSectionTitle.contentEditable === true) {
          subSectionTitle.contentEditable = false;
          const newTitle = subSectionTitle.textContent.trim();
          if (newTitle && newTitle !== subSectionKey) {
            // Rename sub-section in data structure
            const mainKey = subSectionTitle.getAttribute('data-main-key');
            const phaseKey = subSectionTitle.getAttribute('data-phase-key');
            const oldSubSectionKey = subSectionTitle.getAttribute('data-subsection-key');
            const subSection = checklistData[mainKey][phaseKey][oldSubSectionKey];
            delete checklistData[mainKey][phaseKey][oldSubSectionKey];
            checklistData[mainKey][phaseKey][newTitle] = subSection;
            
            // Update data attributes
            subSectionTitle.setAttribute('data-subsection-key', newTitle);
            
            // Update all task IDs that reference this sub-section
            const newCompletedTasks = new Set();
            completedTasks.forEach(taskId => {
              const parts = taskId.split('::');
              if (parts.length >= 3 && parts[1] === phaseKey && parts[2] === oldSubSectionKey) {
                parts[2] = newTitle;
                newCompletedTasks.add(parts.join('::'));
              } else {
                newCompletedTasks.add(taskId);
              }
            });
            completedTasks = newCompletedTasks;
            
            saveProgress();
            updateOverallProgress();
            updateCategoryProgress(phaseKey);
          } else if (!newTitle) {
            subSectionTitle.textContent = subSectionKey;
          }
        }
      };
      
      // Prevent Enter key from creating new line, save instead
      subSectionTitle.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          subSectionTitle.blur();
        }
        if (e.key === 'Escape') {
          subSectionTitle.textContent = subSectionKey;
          subSectionTitle.contentEditable = false;
          subSectionTitle.blur();
        }
      };

      // Create delete button for sub-section
      const subSectionDeleteButton = document.createElement('div');
      subSectionDeleteButton.className = 'swipe-delete';
      subSectionDeleteButton.innerHTML = '<span class="material-symbols-outlined">delete</span>';
      subSectionDeleteButton.onclick = (e) => {
        e.stopPropagation();
        deleteSubSection(mainKey, phaseKey, subSectionKey, subSectionDiv);
      };

      subSectionSwipeContainer.appendChild(subSectionTitle);
      subSectionSwipeContainer.appendChild(subSectionDeleteButton);

      // Add swipe functionality to sub-section header
      addSwipeHandlers(subSectionTitle, subSectionSwipeContainer);

      subSectionDiv.appendChild(subSectionSwipeContainer);

      // Tasks container
      const tasksContainer = document.createElement('div');
      tasksContainer.className = 'divide-y divide-slate-200 dark:divide-slate-700 rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800';

      if (subSection.tasks) {
        subSection.tasks.forEach((task, taskIndex) => {
          // Main task
          const taskRow = createTaskRow(task, mainKey, phaseKey, subSectionKey, taskIndex);
          tasksContainer.appendChild(taskRow);

          // Subtasks if any
          if (task.subtasks) {
            task.subtasks.forEach((subtask, subtaskIndex) => {
              const subtaskRow = createTaskRow(subtask, mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex, true);
              tasksContainer.appendChild(subtaskRow);
            });
          }
        });
      }
      
      // Add "+ Task" button as last item in tasks container
      const addTaskButton = document.createElement('button');
      addTaskButton.className = 'add-button w-full';
      addTaskButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Task</span>';
      addTaskButton.onclick = () => showAddTaskDialog(mainKey, phaseKey, subSectionKey, tasksContainer, subSectionDiv);
      tasksContainer.appendChild(addTaskButton);

      subSectionDiv.appendChild(tasksContainer);
      return subSectionDiv;
    }

    // Create task row
    function createTaskRow(task, mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex = null, isSubtask = false) {
      const taskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex);
      const isCompleted = isTaskCompleted(taskId);
      const hasLinks = task.links && task.links.length > 0;

      // Create swipe container
      const swipeContainer = document.createElement('div');
      swipeContainer.className = 'swipe-container';

      // Create swipe content (the actual row)
      const row = document.createElement('div');
      row.className = `swipe-content flex items-center justify-between p-4 transition-colors duration-150 ${hasLinks ? 'hover:bg-slate-50 dark:hover:bg-slate-700/50 cursor-pointer' : ''}`;
      row.setAttribute('data-task-id', taskId);
      row.setAttribute('data-main-key', mainKey);
      row.setAttribute('data-phase-key', phaseKey);
      row.setAttribute('data-subsection-key', subSectionKey);
      row.setAttribute('data-task-index', taskIndex);
      if (subtaskIndex !== null) {
        row.setAttribute('data-subtask-index', subtaskIndex);
      }
      
      // Make entire row clickable (except checkbox) to show links
      if (hasLinks) {
        row.onclick = (e) => {
          // Don't trigger if clicking checkbox, label (for editing), or if swiped
          if (e.target.type === 'checkbox' || e.target.contentEditable === 'true' || row.classList.contains('swiped')) {
            return;
          }
          showTaskLinks(task.links, task.name, row);
        };
      }
      
      const leftDiv = document.createElement('div');
      leftDiv.className = 'flex items-center space-x-4 flex-1';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'h-5 w-5 rounded border-slate-300 text-primary focus:ring-primary dark:bg-slate-900 dark:border-slate-600';
      checkbox.checked = isCompleted;
      checkbox.onclick = (e) => {
        e.stopPropagation();
        toggleTask(taskId);
        updateTaskRow(row, taskId, task.name);
      };

      const label = document.createElement('span');
      label.className = `text-slate-700 dark:text-slate-300 ${isCompleted ? 'strikethrough' : ''} ${hasLinks ? 'cursor-pointer' : 'cursor-text'}`;
      label.textContent = task.name;
      label.contentEditable = false;
      label.setAttribute('data-task-id', taskId); // Store taskId for reference
      
      // Make label editable on double-click
      label.ondblclick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        if (!label.contentEditable || label.contentEditable === 'false') {
          label.contentEditable = true;
          label.focus();
          // Select all text for easy editing
          const range = document.createRange();
          range.selectNodeContents(label);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      };
      
      // Save edited text when user finishes editing
      label.onblur = () => {
        if (label.contentEditable === 'true' || label.contentEditable === true) {
          label.contentEditable = false;
          const newText = label.textContent.trim();
          const currentTaskName = subtaskIndex !== null 
            ? checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex].subtasks[subtaskIndex].name
            : checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex].name;
          
          if (newText && newText !== currentTaskName) {
            // Update the task name in the data structure
            if (subtaskIndex !== null) {
              checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex].subtasks[subtaskIndex].name = newText;
            } else {
              checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex].name = newText;
            }
            saveProgress();
          } else if (!newText) {
            // Restore original text if empty
            label.textContent = currentTaskName;
          }
        }
      };
      
      // Prevent Enter key from creating new line, save instead
      label.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          label.blur();
        }
        // Allow Escape to cancel editing
        if (e.key === 'Escape') {
          const currentTaskName = subtaskIndex !== null 
            ? checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex].subtasks[subtaskIndex].name
            : checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex].name;
          label.textContent = currentTaskName;
          label.contentEditable = false;
          label.blur();
        }
      };

      leftDiv.appendChild(checkbox);
      leftDiv.appendChild(label);

      const rightIcon = document.createElement('span');
      rightIcon.className = 'material-symbols-outlined text-slate-400 dark:text-slate-500';
      rightIcon.textContent = hasLinks ? 'chevron_right' : '';
      rightIcon.style.pointerEvents = 'none'; // Icon is just visual, row handles click

      row.appendChild(leftDiv);
      if (hasLinks) {
        row.appendChild(rightIcon);
      }

      // Create delete button
      const deleteButton = document.createElement('div');
      deleteButton.className = 'swipe-delete';
      deleteButton.innerHTML = '<span class="material-symbols-outlined">delete</span>';
      deleteButton.onclick = (e) => {
        e.stopPropagation();
        deleteTask(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex, swipeContainer);
      };

      swipeContainer.appendChild(row);
      swipeContainer.appendChild(deleteButton);

      // Add swipe functionality
      addSwipeHandlers(row, swipeContainer);

      return swipeContainer;
    }

    // Update task row appearance
    function updateTaskRow(row, taskId, taskName) {
      const checkbox = row.querySelector('input[type="checkbox"]');
      const label = row.querySelector(`span[data-task-id="${taskId}"]`);
      const isCompleted = isTaskCompleted(taskId);

      if (checkbox) checkbox.checked = isCompleted;
      if (label) {
        if (isCompleted) {
          label.classList.add('strikethrough');
        } else {
          label.classList.remove('strikethrough');
        }
      }
    }

    // Add swipe handlers for touch and mouse events
    function addSwipeHandlers(row, swipeContainer) {
      let startX = 0;
      let currentX = 0;
      let isDragging = false;
      let hasSwiped = false;

      // Touch events
      row.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        isDragging = true;
        hasSwiped = false;
      });

      row.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        currentX = e.touches[0].clientX;
        const diffX = startX - currentX;
        
        // Only allow swiping left (positive diffX)
        if (diffX > 0) {
          e.preventDefault();
          const translateX = Math.min(diffX, 80);
          row.style.transform = `translateX(-${translateX}px)`;
          hasSwiped = translateX > 40; // Threshold for revealing delete button
        }
      });

      row.addEventListener('touchend', () => {
        if (isDragging) {
          if (hasSwiped) {
            row.classList.add('swiped');
            row.style.transform = 'translateX(-80px)';
          } else {
            row.style.transform = 'translateX(0)';
          }
          isDragging = false;
        }
      });

      // Mouse events (for desktop)
      row.addEventListener('mousedown', (e) => {
        // Only allow swipe on right side of row or if already swiped
        const rect = row.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const rowWidth = rect.width;
        
        // Allow swipe if clicking on right 30% of row or if already swiped
        if (clickX > rowWidth * 0.7 || row.classList.contains('swiped')) {
          startX = e.clientX;
          isDragging = true;
          hasSwiped = row.classList.contains('swiped');
          row.style.transition = 'none';
        }
      });

      row.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        currentX = e.clientX;
        const diffX = startX - currentX;
        
        // Only allow swiping left (positive diffX)
        if (diffX > 0) {
          const translateX = Math.min(diffX, 80);
          row.style.transform = `translateX(-${translateX}px)`;
          hasSwiped = translateX > 40;
        }
      });

      row.addEventListener('mouseup', () => {
        if (isDragging) {
          row.style.transition = 'transform 0.3s ease-out';
          if (hasSwiped) {
            row.classList.add('swiped');
            row.style.transform = 'translateX(-80px)';
          } else {
            row.style.transform = 'translateX(0)';
            row.classList.remove('swiped');
          }
          isDragging = false;
        }
      });

      row.addEventListener('mouseleave', () => {
        if (isDragging) {
          row.style.transition = 'transform 0.3s ease-out';
          if (hasSwiped) {
            row.classList.add('swiped');
            row.style.transform = 'translateX(-80px)';
          } else {
            row.style.transform = 'translateX(0)';
            row.classList.remove('swiped');
          }
          isDragging = false;
        }
      });

    }

    // Delete task from checklist
    function deleteTask(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex, swipeContainer) {
      if (!checklistData || !checklistData[mainKey] || !checklistData[mainKey][phaseKey] || !checklistData[mainKey][phaseKey][subSectionKey]) {
        console.error('Invalid task data structure');
        return;
      }

      const subSection = checklistData[mainKey][phaseKey][subSectionKey];
      
      if (subtaskIndex !== null) {
        // Delete a subtask
        if (subSection.tasks && subSection.tasks[taskIndex] && subSection.tasks[taskIndex].subtasks) {
          const subtaskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex);
          completedTasks.delete(subtaskId);
          subSection.tasks[taskIndex].subtasks.splice(subtaskIndex, 1);
          
          // If no subtasks left, remove the subtasks array
          if (subSection.tasks[taskIndex].subtasks.length === 0) {
            delete subSection.tasks[taskIndex].subtasks;
          }
        }
      } else {
        // Delete a main task
        if (subSection.tasks) {
          const taskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex);
          completedTasks.delete(taskId);
          
          // Also delete all subtask IDs if they exist
          if (subSection.tasks[taskIndex] && subSection.tasks[taskIndex].subtasks) {
            subSection.tasks[taskIndex].subtasks.forEach((_, subtaskIdx) => {
              const subtaskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIdx);
              completedTasks.delete(subtaskId);
            });
          }
          
          subSection.tasks.splice(taskIndex, 1);
        }
      }

      // Save updated data
      saveProgress();
      
      // Remove the swipe container from DOM
      swipeContainer.remove();
      
      // Update progress
      updateOverallProgress();
      updateCategoryProgress(phaseKey);
      
      // Update phase checkbox state
      const categoryDiv = document.querySelector(`[data-category-id="${phaseKey}"]`);
      if (categoryDiv) {
        const phaseCheckbox = categoryDiv.querySelector('input[type="checkbox"]');
        if (phaseCheckbox) {
          updatePhaseCheckboxState(phaseKey, mainKey, phaseCheckbox);
        }
      }
    }

    // Delete sub-section and all its tasks
    function deleteSubSection(mainKey, phaseKey, subSectionKey, subSectionDiv) {
      if (!checklistData || !checklistData[mainKey] || !checklistData[mainKey][phaseKey] || !checklistData[mainKey][phaseKey][subSectionKey]) {
        console.error('Invalid sub-section data structure');
        return;
      }

      const phase = checklistData[mainKey][phaseKey];
      const subSection = phase[subSectionKey];

      // Delete all task IDs from completedTasks
      if (subSection.tasks) {
        subSection.tasks.forEach((task, taskIndex) => {
          const taskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex);
          completedTasks.delete(taskId);

          // Also delete all subtask IDs if they exist
          if (task.subtasks) {
            task.subtasks.forEach((_, subtaskIndex) => {
              const subtaskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex);
              completedTasks.delete(subtaskId);
            });
          }
        });
      }

      // Delete the sub-section from the data structure
      delete phase[subSectionKey];

      // Save updated data
      saveProgress();

      // Remove the sub-section div from DOM
      subSectionDiv.remove();

      // Update progress
      updateOverallProgress();
      updateCategoryProgress(phaseKey);

      // Update phase checkbox state
      const categoryDiv = document.querySelector(`[data-category-id="${phaseKey}"]`);
      if (categoryDiv) {
        const phaseCheckbox = categoryDiv.querySelector('input[type="checkbox"]');
        if (phaseCheckbox) {
          updatePhaseCheckboxState(phaseKey, mainKey, phaseCheckbox);
        }
      }
    }

    // Delete phase and all its sub-sections and tasks
    function deletePhase(mainKey, phaseKey, categoryDiv) {
      if (!checklistData || !checklistData[mainKey] || !checklistData[mainKey][phaseKey]) {
        console.error('Invalid phase data structure');
        return;
      }

      const phase = checklistData[mainKey][phaseKey];

      // Delete all task IDs from completedTasks for this entire phase
      for (const subSectionKey in phase) {
        const subSection = phase[subSectionKey];
        if (subSection.tasks) {
          subSection.tasks.forEach((task, taskIndex) => {
            const taskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex);
            completedTasks.delete(taskId);

            // Also delete all subtask IDs if they exist
            if (task.subtasks) {
              task.subtasks.forEach((_, subtaskIndex) => {
                const subtaskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex);
                completedTasks.delete(subtaskId);
              });
            }
          });
        }
      }

      // Delete the phase from the data structure
      delete checklistData[mainKey][phaseKey];

      // Save updated data
      saveProgress();

      // Remove the category div from DOM
      categoryDiv.remove();

      // Update overall progress
      updateOverallProgress();
    }

    // Track currently selected task row
    let selectedTaskRow = null;
    // Track current task info for adding resources
    let currentTaskInfo = null;

    // Get tag color classes based on tag type
    function getTagColorClasses(tag) {
      const tagLower = tag.toLowerCase().trim();
      const tagNormalized = tagLower.replace(/[\/\s]+/g, ' '); // Normalize slashes and spaces
      
      const colorMap = {
        'video': 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300',
        'blog': 'bg-purple-100 text-purple-800 dark:bg-purple-900/30 dark:text-purple-300',
        'social media': 'bg-pink-100 text-pink-800 dark:bg-pink-900/30 dark:text-pink-300',
        'e-commerce': 'bg-orange-100 text-orange-800 dark:bg-orange-900/30 dark:text-orange-300',
        'news': 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300',
        'government official': 'bg-indigo-100 text-indigo-800 dark:bg-indigo-900/30 dark:text-indigo-300',
        'government/official': 'bg-indigo-100 text-indigo-800 dark:bg-indigo-900/30 dark:text-indigo-300',
        'visa': 'bg-cyan-100 text-cyan-800 dark:bg-cyan-900/30 dark:text-cyan-300',
        'housing': 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300',
        'finance': 'bg-emerald-100 text-emerald-800 dark:bg-emerald-900/30 dark:text-emerald-300',
        'legal': 'bg-amber-100 text-amber-800 dark:bg-amber-900/30 dark:text-amber-300',
        'health': 'bg-rose-100 text-rose-800 dark:bg-rose-900/30 dark:text-rose-300',
        'work': 'bg-teal-100 text-teal-800 dark:bg-teal-900/30 dark:text-teal-300',
        'transport': 'bg-sky-100 text-sky-800 dark:bg-sky-900/30 dark:text-sky-300',
        'logistics': 'bg-violet-100 text-violet-800 dark:bg-violet-900/30 dark:text-violet-300',
        'digital': 'bg-fuchsia-100 text-fuchsia-800 dark:bg-fuchsia-900/30 dark:text-fuchsia-300',
        'family': 'bg-lime-100 text-lime-800 dark:bg-lime-900/30 dark:text-lime-300',
        'culture': 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300',
        'planning': 'bg-slate-100 text-slate-800 dark:bg-slate-700/30 dark:text-slate-300'
      };
      
      // Try exact match first (with original case)
      if (colorMap[tag]) {
        return colorMap[tag];
      }
      
      // Try normalized match
      if (colorMap[tagNormalized]) {
        return colorMap[tagNormalized];
      }
      
      // Try lowercase match
      if (colorMap[tagLower]) {
        return colorMap[tagLower];
      }
      
      // Try partial match for tags like "Government/Official"
      for (const [key, value] of Object.entries(colorMap)) {
        const keyNormalized = key.toLowerCase().replace(/[\/\s]+/g, ' ');
        if (tagNormalized.includes(keyNormalized) || keyNormalized.includes(tagNormalized)) {
          return value;
        }
      }
      
      // Default color
      return 'bg-primary/10 text-primary dark:bg-primary/20 dark:text-primary';
    }

    // Show task links in the right column
    function showTaskLinks(links, taskName, taskRow = null) {
      const linksList = document.getElementById('links-list');
      const linksContainer = document.getElementById('links-container');
      const drawerOverlay = document.getElementById('drawer-overlay');
      
      // Extract task info from taskRow if available
      if (taskRow) {
        const mainKey = taskRow.getAttribute('data-main-key');
        const phaseKey = taskRow.getAttribute('data-phase-key');
        const subSectionKey = taskRow.getAttribute('data-subsection-key');
        const taskIndex = parseInt(taskRow.getAttribute('data-task-index'));
        currentTaskInfo = { mainKey, phaseKey, subSectionKey, taskIndex };
      } else {
        currentTaskInfo = null;
      }
      
      // Remove highlight from previously selected row
      if (selectedTaskRow) {
        selectedTaskRow.classList.remove('bg-primary/10', 'border-primary/20', 'border-l-4');
      }
      
      // Highlight current row and update links container background
      if (taskRow) {
        selectedTaskRow = taskRow;
        taskRow.classList.add('bg-primary/10', 'border-primary/20', 'border-l-4');
        // Match the links container background to the highlight color
        linksContainer.classList.remove('bg-white', 'dark:bg-slate-900');
        linksContainer.classList.add('bg-primary/10', 'dark:bg-primary/10');
      } else {
        // Reset background if no task is selected
        linksContainer.classList.remove('bg-primary/10', 'dark:bg-primary/10');
        linksContainer.classList.add('bg-white', 'dark:bg-slate-900');
        selectedTaskRow = null;
      }
      
      // Clear existing links
      linksList.innerHTML = '';

      if (!links || links.length === 0) {
        linksList.innerHTML = '<p class="text-sm text-slate-500 dark:text-slate-400 text-center py-8">No resources available for this task</p>';
        // Add "+ Resource" button if we have task info
        if (currentTaskInfo) {
          const addResourceButton = document.createElement('button');
          addResourceButton.className = 'add-button w-full mt-4';
          addResourceButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>+ Resource</span>';
          addResourceButton.onclick = () => {
            if (currentTaskInfo) {
              showAddResourceDialog(currentTaskInfo.mainKey, currentTaskInfo.phaseKey, currentTaskInfo.subSectionKey, currentTaskInfo.taskIndex);
            }
          };
          linksList.appendChild(addResourceButton);
        }
        // Open drawer on mobile even if no links
        openDrawer();
        return;
      }

      // Create cards for each link with swipe-to-delete
      links.forEach((link, linkIndex) => {
        // Handle both new format (object with link_url) and old format (string)
        const linkUrl = typeof link === 'string' ? link : (link.link_url || '');
        const linkTitle = typeof link === 'string' ? link : (link.title || 'Untitled Resource');
        const linkImage = typeof link === 'string' ? '' : (link.image_url || '');
        const linkTags = typeof link === 'string' ? [] : (link.tags || []);
        
        // Create swipe container
        const swipeContainer = document.createElement('div');
        swipeContainer.className = 'swipe-container';
        
        const card = document.createElement('div');
        card.className = 'swipe-content bg-slate-50 dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700 overflow-hidden hover:shadow-md transition-shadow duration-200 cursor-pointer';
        card.onclick = () => {
          if (linkUrl && !card.classList.contains('swiped')) {
            window.open(linkUrl, '_blank');
          }
        };

        // Image section (if image_url exists)
        if (linkImage && linkImage.trim() !== '') {
          const imageDiv = document.createElement('div');
          imageDiv.className = 'w-full bg-white overflow-hidden flex items-center justify-center p-3';
          imageDiv.style.minHeight = '120px';
          imageDiv.style.maxHeight = '200px';
          const img = document.createElement('img');
          img.src = linkImage;
          img.alt = linkTitle;
          img.className = 'w-full h-auto max-h-full object-contain';
          img.style.maxWidth = '100%';
          img.onerror = () => {
            // Hide image on error
            imageDiv.style.display = 'none';
          };
          imageDiv.appendChild(img);
          card.appendChild(imageDiv);
        }

        // Content section
        const contentDiv = document.createElement('div');
        contentDiv.className = 'p-4';

        // Title
        const titleDiv = document.createElement('div');
        titleDiv.className = 'font-semibold text-slate-900 dark:text-white mb-2 line-clamp-2';
        titleDiv.textContent = linkTitle;
        contentDiv.appendChild(titleDiv);

        // Tags
        if (linkTags && Array.isArray(linkTags) && linkTags.length > 0) {
          const tagsDiv = document.createElement('div');
          tagsDiv.className = 'flex flex-wrap gap-1.5 mt-2';
          linkTags.forEach(tag => {
            const tagSpan = document.createElement('span');
            tagSpan.className = `inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${getTagColorClasses(tag)}`;
            tagSpan.textContent = tag;
            tagsDiv.appendChild(tagSpan);
          });
          contentDiv.appendChild(tagsDiv);
        }

        card.appendChild(contentDiv);
        
        // Create delete button
        const deleteButton = document.createElement('div');
        deleteButton.className = 'swipe-delete';
        deleteButton.innerHTML = '<span class="material-symbols-outlined">delete</span>';
        deleteButton.onclick = (e) => {
          e.stopPropagation();
          deleteResource(currentTaskInfo.mainKey, currentTaskInfo.phaseKey, currentTaskInfo.subSectionKey, currentTaskInfo.taskIndex, linkIndex, swipeContainer);
        };
        
        swipeContainer.appendChild(card);
        swipeContainer.appendChild(deleteButton);
        
        // Add swipe functionality
        addSwipeHandlers(card, swipeContainer);
        
        linksList.appendChild(swipeContainer);
      });
      
      // Add "+ Resource" button at the bottom
      if (currentTaskInfo) {
        const addResourceButton = document.createElement('button');
        addResourceButton.className = 'add-button w-full mt-4';
        addResourceButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Resource</span>';
        addResourceButton.onclick = () => {
          if (currentTaskInfo) {
            showAddResourceDialog(currentTaskInfo.mainKey, currentTaskInfo.phaseKey, currentTaskInfo.subSectionKey, currentTaskInfo.taskIndex);
          }
        };
        linksList.appendChild(addResourceButton);
      }
      
      // Open drawer on mobile
      openDrawer();
    }
    
    // Delete resource from task
    function deleteResource(mainKey, phaseKey, subSectionKey, taskIndex, linkIndex, swipeContainer) {
      const task = checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex];
      if (task.links && task.links[linkIndex]) {
        task.links.splice(linkIndex, 1);
        saveProgress();
        swipeContainer.remove();
        
        // Refresh the links display
        const taskRow = document.querySelector(`[data-task-id="${getTaskId(mainKey, phaseKey, subSectionKey, taskIndex)}"]`)?.closest('.swipe-content');
        if (taskRow) {
          showTaskLinks(task.links, task.name, taskRow);
        }
      }
    }

    // Drawer functions for mobile
    function openDrawer() {
      const linksContainer = document.getElementById('links-container');
      const drawerOverlay = document.getElementById('drawer-overlay');
      
      // Only show drawer on mobile (below lg breakpoint)
      if (window.innerWidth < 1024) {
        linksContainer.classList.remove('translate-x-full');
        linksContainer.classList.add('translate-x-0');
        if (drawerOverlay) {
          drawerOverlay.classList.remove('hidden');
        }
        // Prevent body scroll when drawer is open
        document.body.style.overflow = 'hidden';
      }
    }

    function closeDrawer() {
      const linksContainer = document.getElementById('links-container');
      const drawerOverlay = document.getElementById('drawer-overlay');
      
      linksContainer.classList.remove('translate-x-0');
      linksContainer.classList.add('translate-x-full');
      if (drawerOverlay) {
        drawerOverlay.classList.add('hidden');
      }
      // Restore body scroll
      document.body.style.overflow = '';
    }

    // Toggle category expand/collapse
    function toggleCategory(categoryDiv) {
      const content = categoryDiv.querySelector('.category-content');
      const caret = categoryDiv.querySelector('.category-caret');
      const isExpanded = content.style.display !== 'none';

      if (isExpanded) {
        content.style.display = 'none';
        caret.textContent = 'chevron_right';
        caret.style.transform = 'rotate(0deg)';
      } else {
        content.style.display = 'block';
        caret.textContent = 'expand_more';
      }
    }

    // Calculate category progress
    function calculateCategoryProgress(phaseKey) {
      const mainKey = Object.keys(checklistData)[0];
      const phase = checklistData[mainKey][phaseKey];
      let total = 0;
      let completed = 0;

      for (const subSectionKey in phase) {
        const subSection = phase[subSectionKey];
        if (subSection.tasks) {
          subSection.tasks.forEach((task, taskIndex) => {
            const taskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex);
            total++;
            if (isTaskCompleted(taskId)) completed++;

            if (task.subtasks) {
              task.subtasks.forEach((subtask, subtaskIndex) => {
                const subtaskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex);
                total++;
                if (isTaskCompleted(subtaskId)) completed++;
              });
            }
          });
        }
      }

      return total > 0 ? Math.round((completed / total) * 100) : 0;
    }

    // Update category progress
    function updateCategoryProgress(phaseKey = null) {
      const mainKey = Object.keys(checklistData)[0];
      const phases = checklistData[mainKey];

      if (phaseKey) {
        // Update specific category
        const categoryDiv = document.querySelector(`[data-category-id="${phaseKey}"]`);
        if (categoryDiv) {
          const progress = calculateCategoryProgress(phaseKey);
          const progressText = categoryDiv.querySelector('.category-progress-text');
          const progressBar = categoryDiv.querySelector('.category-progress-bar');
          if (progressText) progressText.textContent = `${progress}% Complete`;
          if (progressBar) progressBar.style.width = `${progress}%`;
        }
      } else {
        // Update all categories
        for (const key in phases) {
          updateCategoryProgress(key);
        }
      }
    }

    // Update overall progress
    function updateOverallProgress() {
      const mainKey = Object.keys(checklistData)[0];
      const phases = checklistData[mainKey];
      let total = 0;
      let completed = 0;

      for (const phaseKey in phases) {
        const phase = phases[phaseKey];
        for (const subSectionKey in phase) {
          const subSection = phase[subSectionKey];
          if (subSection.tasks) {
            subSection.tasks.forEach((task, taskIndex) => {
              const taskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex);
              total++;
              if (isTaskCompleted(taskId)) completed++;

              if (task.subtasks) {
                task.subtasks.forEach((subtask, subtaskIndex) => {
                  const subtaskId = getTaskId(mainKey, phaseKey, subSectionKey, taskIndex, subtaskIndex);
                  total++;
                  if (isTaskCompleted(subtaskId)) completed++;
                });
              }
            });
          }
        }
      }

      const percent = total > 0 ? Math.round((completed / total) * 100) : 0;
      document.getElementById('overall-progress-percent').textContent = `${percent}%`;
      document.getElementById('overall-progress-text').textContent = 
        `You've completed ${completed} out of ${total} tasks. ${completed < total ? 'Keep going!' : 'Congratulations!'}`;
      document.getElementById('overall-progress-bar').style.width = `${percent}%`;
    }

    // Handle signup button click - open Google Form
    function handleSignup() {
      console.log('Signup button clicked - opening Google Form');
      window.open('https://forms.gle/zCZ1LTBNgAjFC3zx6', '_blank');
    }

    // Add new phase
    function addNewPhase(mainKey) {
      const newPhaseKey = `New Phase ${Object.keys(checklistData[mainKey]).length + 1}`;
      checklistData[mainKey][newPhaseKey] = {};
      saveProgress();
      renderChecklist();
    }

    // Add new category/sub-section
    function addNewCategory(mainKey, phaseKey, contentDiv) {
      const phase = checklistData[mainKey][phaseKey];
      const categoryCount = Object.keys(phase).length;
      const newCategoryKey = `New Category ${categoryCount + 1}`;
      phase[newCategoryKey] = { tasks: [] };
      saveProgress();
      
      // Re-render just this phase's content
      const categoryDiv = contentDiv.closest('[data-category-id]');
      const oldContent = categoryDiv.querySelector('.category-content');
      const newContent = document.createElement('div');
      newContent.className = 'category-content space-y-6';
      newContent.style.display = oldContent.style.display;
      
      for (const subSectionKey in phase) {
        const subSection = phase[subSectionKey];
        const subSectionElement = createSubSectionElement(subSectionKey, subSection, mainKey, phaseKey);
        newContent.appendChild(subSectionElement);
      }
      
      // Add "+ Category" button
      const addCategoryButton = document.createElement('button');
      addCategoryButton.className = 'add-button w-full';
      addCategoryButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Category</span>';
      addCategoryButton.onclick = () => addNewCategory(mainKey, phaseKey, newContent);
      newContent.appendChild(addCategoryButton);
      
      oldContent.replaceWith(newContent);
      updateCategoryProgress(phaseKey);
    }

    // Show dialog to add new task
    function showAddTaskDialog(mainKey, phaseKey, subSectionKey, tasksContainer, subSectionDiv) {
      const overlay = document.createElement('div');
      overlay.className = 'dialog-overlay';
      overlay.onclick = (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      };
      
      const dialog = document.createElement('div');
      dialog.className = 'dialog-content';
      dialog.onclick = (e) => e.stopPropagation();
      
      dialog.innerHTML = `
        <div class="dialog-header">
          <h3 class="dialog-title">Add New Task</h3>
          <button class="dialog-close" id="dialog-close-btn">
            <span class="material-symbols-outlined">close</span>
          </button>
        </div>
        <form id="add-task-form">
          <div class="dialog-form-group">
            <label class="dialog-label" for="task-name">Task Name *</label>
            <input type="text" id="task-name" class="dialog-input" required placeholder="Enter task name">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="task-description">Description (optional)</label>
            <textarea id="task-description" class="dialog-textarea" placeholder="Enter task description"></textarea>
          </div>
          <div class="dialog-actions">
            <button type="button" class="btn-secondary" id="dialog-cancel-btn">Cancel</button>
            <button type="submit" class="btn-primary">Add Task</button>
          </div>
        </form>
      `;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // Wire up close and cancel buttons
      const closeBtn = dialog.querySelector('#dialog-close-btn');
      const cancelBtn = dialog.querySelector('#dialog-cancel-btn');
      const closeDialog = () => overlay.remove();
      if (closeBtn) closeBtn.onclick = closeDialog;
      if (cancelBtn) cancelBtn.onclick = closeDialog;
      
      const form = dialog.querySelector('#add-task-form');
      form.onsubmit = (e) => {
        e.preventDefault();
        const taskName = dialog.querySelector('#task-name').value.trim();
        const taskDescription = dialog.querySelector('#task-description').value.trim();
        
        if (taskName) {
          try {
            addNewTask(mainKey, phaseKey, subSectionKey, taskName, taskDescription, tasksContainer, subSectionDiv);
            overlay.remove();
          } catch (error) {
            console.error('Error adding task:', error);
            alert('Error adding task: ' + error.message);
          }
        } else {
          alert('Please enter a task name');
        }
      };
      
      dialog.querySelector('#task-name').focus();
    }

    // Add new task
    function addNewTask(mainKey, phaseKey, subSectionKey, taskName, taskDescription, tasksContainer, subSectionDiv) {
      // Validate inputs
      if (!checklistData || !checklistData[mainKey]) {
        console.error('Invalid mainKey:', mainKey);
        throw new Error('Invalid checklist data structure');
      }
      
      // Ensure phase exists
      if (!checklistData[mainKey][phaseKey]) {
        console.log('Creating missing phase:', phaseKey);
        checklistData[mainKey][phaseKey] = {};
      }
      
      // Ensure sub-section exists
      if (!checklistData[mainKey][phaseKey][subSectionKey]) {
        console.log('Creating missing sub-section:', subSectionKey);
        checklistData[mainKey][phaseKey][subSectionKey] = { tasks: [] };
      }
      
      const subSection = checklistData[mainKey][phaseKey][subSectionKey];
      if (!subSection) {
        console.error('Sub-section is null:', subSectionKey);
        throw new Error('Sub-section does not exist');
      }
      
      if (!subSection.tasks) {
        subSection.tasks = [];
      }
      
      const newTask = {
        name: taskName,
        description: taskDescription || '',
        links: []
      };
      
      subSection.tasks.push(newTask);
      const taskIndex = subSection.tasks.length - 1;
      
      // Remove the "+ Task" button temporarily
      const addButton = tasksContainer.querySelector('.add-button');
      if (addButton) {
        addButton.remove();
      }
      
      // Add the new task row
      const taskRow = createTaskRow(newTask, mainKey, phaseKey, subSectionKey, taskIndex);
      tasksContainer.appendChild(taskRow);
      
      // Re-add the "+ Task" button
      const newAddButton = document.createElement('button');
      newAddButton.className = 'add-button w-full';
      newAddButton.innerHTML = '<span class="material-symbols-outlined">add</span><span>New Task</span>';
      newAddButton.onclick = () => showAddTaskDialog(mainKey, phaseKey, subSectionKey, tasksContainer, subSectionDiv);
      tasksContainer.appendChild(newAddButton);
      
      saveProgress();
      updateOverallProgress();
      updateCategoryProgress(phaseKey);
    }

    // Show dialog to add new resource
    function showAddResourceDialog(mainKey, phaseKey, subSectionKey, taskIndex) {
      const overlay = document.createElement('div');
      overlay.className = 'dialog-overlay';
      overlay.onclick = (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      };
      
      const dialog = document.createElement('div');
      dialog.className = 'dialog-content';
      dialog.onclick = (e) => e.stopPropagation();
      
      dialog.innerHTML = `
        <div class="dialog-header">
          <h3 class="dialog-title">Add New Resource</h3>
          <button class="dialog-close" id="dialog-close-btn">
            <span class="material-symbols-outlined">close</span>
          </button>
        </div>
        <form id="add-resource-form">
          <div class="dialog-form-group">
            <label class="dialog-label" for="resource-title">Title *</label>
            <input type="text" id="resource-title" class="dialog-input" required placeholder="Enter resource title">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="resource-url">URL *</label>
            <input type="url" id="resource-url" class="dialog-input" required placeholder="https://example.com">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="resource-image">Image URL (optional)</label>
            <input type="url" id="resource-image" class="dialog-input" placeholder="https://example.com/image.jpg">
          </div>
          <div class="dialog-form-group">
            <label class="dialog-label" for="resource-tags">Tags (comma-separated, optional)</label>
            <input type="text" id="resource-tags" class="dialog-input" placeholder="blog, video, official">
          </div>
          <div class="dialog-actions">
            <button type="button" class="btn-secondary" id="dialog-cancel-btn">Cancel</button>
            <button type="submit" class="btn-primary">Add Resource</button>
          </div>
        </form>
      `;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // Wire up close and cancel buttons
      const closeBtn = dialog.querySelector('#dialog-close-btn');
      const cancelBtn = dialog.querySelector('#dialog-cancel-btn');
      const closeDialog = () => overlay.remove();
      if (closeBtn) closeBtn.onclick = closeDialog;
      if (cancelBtn) cancelBtn.onclick = closeDialog;
      
      const form = dialog.querySelector('#add-resource-form');
      form.onsubmit = (e) => {
        e.preventDefault();
        const title = dialog.querySelector('#resource-title').value.trim();
        const url = dialog.querySelector('#resource-url').value.trim();
        const image = dialog.querySelector('#resource-image').value.trim();
        const tagsStr = dialog.querySelector('#resource-tags').value.trim();
        const tags = tagsStr ? tagsStr.split(',').map(t => t.trim()).filter(t => t) : [];
        
        if (title && url) {
          try {
            addNewResource(mainKey, phaseKey, subSectionKey, taskIndex, title, url, image, tags);
            overlay.remove();
            // Refresh the links display
            const task = checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex];
            const taskRow = document.querySelector(`[data-task-id="${getTaskId(mainKey, phaseKey, subSectionKey, taskIndex)}"]`)?.closest('.swipe-content');
            if (taskRow) {
              showTaskLinks(task.links, task.name, taskRow);
            }
          } catch (error) {
            console.error('Error adding resource:', error);
            alert('Error adding resource: ' + error.message);
          }
        } else {
          alert('Please enter both title and URL');
        }
      };
      
      dialog.querySelector('#resource-title').focus();
    }

    // Add new resource to task
    function addNewResource(mainKey, phaseKey, subSectionKey, taskIndex, title, url, image, tags) {
      const task = checklistData[mainKey][phaseKey][subSectionKey].tasks[taskIndex];
      if (!task.links) {
        task.links = [];
      }
      
      const newResource = {
        title: title,
        link_url: url,
        image_url: image || '',
        tags: tags || []
      };
      
      task.links.push(newResource);
      saveProgress();
    }

    // Wire up Overall Progress swipe and refresh
    function wireUpOverallProgressSwipe() {
      const progressContent = document.getElementById('overall-progress-content');
      const progressContainer = progressContent?.closest('.swipe-container');
      const refreshButton = document.getElementById('overall-progress-refresh');
      
      if (!progressContent || !progressContainer || !refreshButton) {
        console.warn('Overall Progress elements not found');
        return;
      }
      
      // Wire up refresh button click
      refreshButton.onclick = (e) => {
        e.stopPropagation();
        resetChecklist();
      };
      
      // Add swipe handlers
      addSwipeHandlers(progressContent, progressContainer);
    }

    // Wire up signup button
    function wireUpSignupButton() {
      // Find signup button by text content or by being in header
      const signupButton = Array.from(document.querySelectorAll('a')).find(a => 
        a.textContent.trim() === 'Signup' && a.closest('header')
      );
      if (signupButton) {
        console.log('Signup button found, handler function:', typeof handleSignup);
        // Remove existing onclick to avoid double-firing, then add event listener
        signupButton.removeAttribute('onclick');
        signupButton.addEventListener('click', function(e) {
          console.log('Signup button clicked via event listener');
          e.preventDefault();
          handleSignup();
        });
      } else {
        console.warn('Signup button not found!');
      }
    }

    // Wire up drawer close functionality
    function wireUpDrawer() {
      const closeBtn = document.getElementById('close-drawer-btn');
      const overlay = document.getElementById('drawer-overlay');
      
      if (closeBtn) {
        closeBtn.addEventListener('click', closeDrawer);
      }
      
      if (overlay) {
        overlay.addEventListener('click', closeDrawer);
      }
      
      // Close drawer on window resize if switching to desktop
      window.addEventListener('resize', () => {
        if (window.innerWidth >= 1024) {
          closeDrawer();
        }
      });
    }
    
    // Global handler to close swiped rows when clicking outside (only add once)
    if (!swipeCloseHandlerAdded) {
      document.addEventListener('click', (e) => {
        // Find all swiped rows
        const swipedRows = document.querySelectorAll('.swipe-content.swiped');
        swipedRows.forEach(swipedRow => {
          const swipeContainer = swipedRow.closest('.swipe-container');
          if (swipeContainer && !swipeContainer.contains(e.target)) {
            swipedRow.classList.remove('swiped');
            swipedRow.style.transform = 'translateX(0)';
          }
        });
      }, true);
      swipeCloseHandlerAdded = true;
    }
    
    // Initialize on page load
    init();
    
    // Wire up signup button when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        wireUpSignupButton();
        wireUpDrawer();
      });
    } else {
      // DOM already loaded
      wireUpSignupButton();
      wireUpDrawer();
    }
  </script>

  <!-- UserBack Feedback Widget -->
  <script>
    window.Userback = window.Userback || {};

    Userback.access_token = "A-w4OQPAJGddZyhz0o2RCfyuaQk";

    (function(d) {
      var s = d.createElement('script');s.async = true;s.src = 'https://static.userback.io/widget/v1.js';(d.head || d.body).appendChild(s);
    })(document);
  </script>
</body>
</html>

